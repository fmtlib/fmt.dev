<pre class='metadata'>
Title: std::print more types faster with less memory
Shortname: P3235
Revision: 0
Audience: LEWG
Status: D
Group: WG21
URL:
Editor: Victor Zverovich, victor.zverovich@gmail.com
No abstract: true
Date: 2024-04-13
Markup Shorthands: markdown yes
</pre>

<p style="text-align: right">
"A common mistake that people make when trying to design something completely
foolproof is to underestimate the ingenuity of complete fools."
 â€• Douglas Adams
</p>

Introduction {#intro}
============

[[P3107]] enabled an efficient implementation of `std::print` and applied the
optimization to fundamental and string types. The current paper applies this
important optimization to other standard types.

Proposal {#proposal}
========

[[P3107]] "Permit an efficient implementation of std::print" brought
significant speedups (more than 20% in some cases) to `std::print` and
eliminated the neeed for dynamic memory allocations in the common case by
enabling direct writes into the stream buffer. To speed up the adoption of the
fix, [[P3107]] limited the scope to fundamental and string types but it is, of
course, beneficial to enable this optimization for other standard types that
have formatters. This was even discussed in LEWG that encouraged writing
another paper:

> LEWG requests for an additional paper to fix formatters for ranges

The current paper proposes opting in formatters for ranges and other standard
types into this optimization.

Here is a list of standard formatters that are not yet opted into the
`std::print` optimization.

Date and time formatters [[time.syn](https://eel.is/c++draft/time.syn)]:

```
  template<class Rep, class Period, class charT>
    struct formatter<chrono::duration<Rep, Period>, charT>;
  template<class Duration, class charT>
    struct formatter<chrono::sys_time<Duration>, charT>;
  template<class Duration, class charT>
    struct formatter<chrono::utc_time<Duration>, charT>;
  template<class Duration, class charT>
    struct formatter<chrono::tai_time<Duration>, charT>;
  template<class Duration, class charT>
    struct formatter<chrono::gps_time<Duration>, charT>;
  template<class Duration, class charT>
    struct formatter<chrono::file_time<Duration>, charT>;
  template<class Duration, class charT>
    struct formatter<chrono::local_time<Duration>, charT>;
  template<class Duration, class charT>
    struct formatter<chrono::local-time-format-t<Duration>, charT>;
  template<class charT> struct formatter<chrono::day, charT>;
  template<class charT> struct formatter<chrono::month, charT>;
  template<class charT> struct formatter<chrono::year, charT>;
  template<class charT> struct formatter<chrono::weekday, charT>;
  template<class charT> struct formatter<chrono::weekday_indexed, charT>;
  template<class charT> struct formatter<chrono::weekday_last, charT>;
  template<class charT> struct formatter<chrono::month_day, charT>;
  template<class charT> struct formatter<chrono::month_day_last, charT>;
  template<class charT> struct formatter<chrono::month_weekday, charT>;
  template<class charT> struct formatter<chrono::month_weekday_last, charT>;
  template<class charT> struct formatter<chrono::year_month, charT>;
  template<class charT> struct formatter<chrono::year_month_day, charT>;
  template<class charT> struct formatter<chrono::year_month_day_last, charT>;
  template<class charT> struct formatter<chrono::year_month_weekday, charT>;
  template<class charT> struct formatter<chrono::year_month_weekday_last, charT>;
  template<class Rep, class Period, class charT>
    struct formatter<chrono::hh_mm_ss<duration<Rep, Period>>, charT>;
  template<class charT> struct formatter<chrono::sys_info, charT>;
  template<class charT> struct formatter<chrono::local_info, charT>;
  template<class Duration, class TimeZonePtr, class charT>
    struct formatter<chrono::zoned_time<Duration, TimeZonePtr>, charT>;
```

`Rep` is an arithmetic type, `Period` is `std::ratio<...>`, `Duration` is
`std::duration<...>` and `charT` is `char` or `wchar_t` so all chrono formatters
except the one for `std::zoned_time` can be unconditionally opted into the
optimization. The formatter for `std::zoned_time` can be opted in for the default
`TimeZonePtr` (`const std::chrono::time_zone*`) but not arbitrary user-provided
`TimeZonePtr` that can be potentially locking.

<!-- https://www.godbolt.org/z/v87aY37GG --> 

`std::thread::id` formatter [[thread.thread.id](
https://eel.is/c++draft/thread.thread.id)]:

```
  template<class charT> struct formatter<thread::id, charT>;
```

Stacktrace formatters [[stacktrace.syn](
https://eel.is/c++draft/stacktrace.syn)]:

```
  // [stacktrace.format], formatting support
  template<> struct formatter<stacktrace_entry>;
  template<class Allocator> struct formatter<basic_stacktrace<Allocator>>;
```

`std::vector<bool>` formatter [[vector.syn](
https://eel.is/c++draft/vector.syn)]:

```
  // [vector.bool.fmt], formatter specialization for vector<bool>
  template<class T, class charT> requires is-vector-bool-reference<T>
    struct formatter<T, charT>;
```

`std::filesystem::path` formatter added in [[P2845]] and, as of 14 Apr 2024, in
the process of being merged into the standard draft:

```
// [fs.path.fmt], formatter
template<class charT> struct formatter<filesystem::path, charT>;
```

`std::thread::id`, stacktrace, `std::vector<bool>` and `std::filesystem::path`
formatters don't invoke any user code and can be opted into the optimization.

Tuple formatter [[format.tuple](https://eel.is/c++draft/format.tuple)]:

```
  template<class charT, formattable<charT>... Ts>
  struct formatter<pair-or-tuple<Ts...>, charT> {
    ...
  };
```

The tuple formatter can be opted in if all the element formatters are opted in.

Range formatter [[format.syn](https://eel.is/c++draft/format.syn)]:

```
  // [format.range.fmtmap], [format.range.fmtset], [format.range.fmtstr], specializations for maps, sets, and strings
  template<ranges::input_range R, class charT>
    requires (format_kind<R> != range_format::disabled) &&
             formattable<ranges::range_reference_t<R>, charT>
  struct formatter<R, charT> : range-default-formatter<format_kind<R>, R, charT> { };
```

`std::queue` and `std::priority_queue` formatters [[queue.syn](
https://eel.is/c++draft/queue.syn)]:

```
  // [container.adaptors.format], formatter specialization for queue
  template<class charT, class T, formattable<charT> Container>
    struct formatter<queue<T, Container>, charT>;

  ...

  // [container.adaptors.format], formatter specialization for priority_queue
  template<class charT, class T, formattable<charT> Container, class Compare>
    struct formatter<priority_queue<T, Container, Compare>, charT>;
```

`std::stack` formatter [[stack.syn](https://eel.is/c++draft/stack.syn)]:

```
  // [container.adaptors.format], formatter specialization for stack
  template<class charT, class T, formattable<charT> Container>
    struct formatter<stack<T, Container>, charT>;
```

Range and container adaptor formatters are the most interesting case because
formatting requires iterating and user-defined iterators can be locking, at
least in principle. None of the standard containers, ranges and container
adaptors and even common concurrent containers such as `concurrent_vector` from
[[TBB]] provide locking iterators. For this reason, the current paper proposes
opting range and adaptor formatters into the optimization by default.

<!-- TODO: wording -->

<pre class=biblio>
{
  "P2845": {
    "title": "Formatting of std::filesystem::path",
    "authors": ["Victor Zverovich"],
    "href": "https://wg21.link/p2845"
  },
  "P3107": {
    "title": "Permit an efficient implementation of std::print",
    "authors": ["Victor Zverovich"],
    "href": "https://wg21.link/p3107"
  },
  "TBB": {
    "title": "oneAPI Threading Building Blocks (oneTBB)",
    "href": "https://oneapi-src.github.io/oneTBB/"
  }
}
</pre>
