<pre class='metadata'>
Title: When paths go WTF: making formatting lossless
Shortname: P3904
Revision: 0
Audience: SG16
Status: P
Group: WG21
URL:
Editor: Victor Zverovich, victor.zverovich@gmail.com
No abstract: true
Date: 2025-10-30
Markup Shorthands: markdown yes
</pre>

<p style="text-align: right">
"Compatibility means deliberately repeating other people’s mistakes." -
David Wheeler
</p>

# Introduction # {#intro}

[[P2845]], adopted in C++26, added formatting support for
`std::filesystem::path`, addressing encoding issues and making formatting
lossless except for one case, unpaired surrogates on Windows. This paper
proposes addressing this case and making formatting 100% lossless by default
via the WTF-8 encoding ([[WTF]]). This will improve consistency in path
handling between Windows and POSIX platforms and align with the design of
`std::format` where the default formatting is normally lossless.

# Motivation # {#motivation}

[[P2845]] made it possible to format and print Unicode paths, even on Windows,
which historically had problems because of legacy code pages. For example

```c++
std::print("{}\n", std::filesystem::path(L"Шчучыншчына"));
```

is correctly formatted and printed on Windows when the literal encoding is
UTF-8 regardles of the Active Code Page.

However, paths are not guaranteed to be valid Unicode or even text. In general
they are just sequences of bytes (or 16-bit values on Windows) which often but
not always contain Unicode text, quoting [[WIN32-FILEIO]]:

> the file system treats path and file names as an opaque sequence of `WCHAR`s

This is also true on POSIX ([[PEP383]]):

> File names, environment variables, and command line arguments are defined as
> being character data in POSIX; the C APIs however allow passing arbitrary
> bytes - whether these conform to a certain encoding or not.

Arbitrary paths are formatted on POSIX such that there is no data loss.
Unfortunately this is not the case on Windows, for example:

```c++
auto p1 = std::filesystem::path(L"\xD800"); // a lone surrogate
auto p2 = std::filesystem::path(L"\xD801"); // another lone surrogate
auto s1 = std::format("{}\n", p1); // s1 == "�"
auto s2 = std::format("{}\n", p2); // s2 == "�"
```

Apart from being inconsistent between platforms, this makes it impossible to
reliably round trip paths. For example, `p1` and `p2` above are two distinct
paths that are formatted as the same string. This may result in a silent data
loss and is remarkably different from other standard formatters such as the ones
for floating point numbers which are specifically designed to round trip.

For comparison, on POSIX formatting of arbitrary paths including the ones that
are not valid Unicode works as expected and is lossless:

```c++
auto p = std::filesystem::path("\x80");
auto s = std::format("{}\n", p); // s == "\x80"
```

# Proposal # {#proposal}

The current paper proposes preventing data loss and formatting ill-formed
UTF-16 paths using WTF-8 (Wobbly Transformation Format − 8-bit) which is
"a superset of UTF-8 that can losslessly represent arbitrary sequences of
16-bit code unit (even if ill-formed in UTF-16) but preserves the other
well-formedness constraints of UTF-8." ([[WTF]])

<table>
<tr>
  <th>Code
  <th>Before
  <th>After
</tr>
<tr>
<td>
```c++
std::format("{}\n", std::filesystem::path(L"\xD800"));
```
<td>
```
"�"
```
<td>
```
"\xED\xA0\x80"
```
</tr>
<tr>
<td>
```c++
std::format("{}\n", std::filesystem::path(L"\xD801"));
```
<td>
```
"�"
```
<td>
```
"\xED\xA0\x81"
```
</tr>
</table>

At the same time this will preserve the observable behavior for `std::print`
when printing to a terminal. For example:

```c++
std::print("{}\n", std::filesystem::path(L"\xD800"));
```

will still print

```
�
```

on implementations that follow the recommended practice from
[[ostream.formatted.print](https://eel.is/c++draft/ostream.formatted.print)]:

> *Recommended practice*: For `vprint_unicode`, if invoking the native Unicode
> API requires transcoding, implementations should substitute invalid code
> units with U+FFFD REPLACEMENT CHARACTER per the Unicode Standard, Chapter 3.9
> U+FFFD Substitution in Conversion.

WTF-8 is used to handle invalid UTF-16 in Rust ([[RUST-OSSTRING]]) and Node.js
libuv ([[LIBUV]]). Python also handles this but with a different mechanism
([[PEP383]]).

<pre class=biblio>
{
  "P2845": {
    "title": "Formatting of std::filesystem::path",
    "authors": ["Victor Zverovich"],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2845r8.html"
  },
  "PEP383": {
    "title": "PEP 383 – Non-decodable Bytes in System Character Interfaces",
    "authors": ["Martin von Löwis"],
    "href": "https://peps.python.org/pep-0383/"
  },
  "RUST-OSSTRING": {
    "title": "OsString Struct. The Rust Standard Library.",
    "authors": "Rust Project Developers",
    "href": "https://doc.rust-lang.org/std/ffi/struct.OsString.html"
  },
  "LIBUV": {
    "title": "Miscellaneous utilities. libuv Documentation.",
    "authors": "libuv contributors,",
    "href": "https://docs.libuv.org/en/v1.x/misc.html"
  },
  "WTF": {
    "title": "The WTF-8 encoding",
    "authors": ["Simon Sapin"],
    "href": "https://wtf-8.codeberg.page/"
  },
  "WIN32-FILEIO": {
    "authors": ["Microsoft Corporation"],
    "title":
      "Maximum Path Length Limitation – Local file systems",
    "href":
      "https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation"
  }
}
</pre>
