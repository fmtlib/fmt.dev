<pre class='metadata'>
Title: <code>to_string</code> or not <code>to_string</code>
Shortname: D2587
Revision: 1
Audience: LEWG
Status: D
Group: WG21
URL:
Editor: Victor Zverovich, victor.zverovich@gmail.com
No abstract: true
Date: 2022-06-03
Markup Shorthands: markdown yes
</pre>

<p style="text-align: right">
"Though this be madness, yet there is method in ’t."
― Polonius
</p>

Introduction {#intro}
============

C++11 introduced a set of `std::to_string` overloads for integral and
floating-point types. Fortunately for integral and unfortunately for
floating-point overloads they are all defined in terms of `sprintf`
inconsistently with C++ formatted output functions ([[N4910]]). Additionally,
the choice of the floating-point format makes `std::to_string` of very limited
use in practice. This paper proposes fixing these issues while retaining
existing semantics of integral overloads.

Revision history {#hist}
================

Changes since R0:

* Added an entry to Annex C.
* Added a feature test macro.
* Applied the same changes to `to_wstring` in the wording.

Examples {#examples}
========

Consider the following example:

```c++
auto loc = std::locale("uk_UA.UTF-8");
std::locale::global(loc);
std::cout.imbue(loc);
setlocale(LC_ALL, "C");

std::cout << "iostreams:\n";
std::cout << 1234 << "\n";
std::cout << 1234.5 << "\n";

std::cout << "\nto_string:\n";
std::cout << std::to_string(1234) << "\n";
std::cout << std::to_string(1234.5) << "\n";

setlocale(LC_ALL, "uk_UA.UTF-8");

std::cout << "\nto_string (uk_UA.UTF-8 C locale):\n";
std::cout << std::to_string(1234) << "\n";
std::cout << std::to_string(1234.5) << "\n";
```

It prints:

```text
iostreams:
1 234
1 234,5

to_string:
1234
1234.500000

to_string (uk_UA.UTF-8 C locale):
1234
1234,500000
```

Since `std::to_string` uses the global C locale and no grouping the integral
overloads are effectively unlocalized. The output of floating-point overloads is
inconsistent with that of iostreams because the former takes the decimal
point from the global C locale and doesn't do grouping.

Additionally, due to an unfortunate choice of the fixed format in the
floating-point overloads they are only useful for numbers in a limited exponent
range. For example:

<!-- https://godbolt.org/z/rv9hbsoE4 -->
```c++
std::cout << std::to_string(std::numeric_limits<double>::max());
```

prints

```
1797693134862315708145274237317043567980705675258449965989174768031572607800285
3876058955863276687817154045895351438246423432132688946418276846754670353751698
6049910576551282076245490090389328944075868508455133942304583236903222948165808
559332123348274797826204144723168738177180919299881250404026184124858368.000000
```
(line breaks inserted for readability)

Here only the first 17 digits are meaningful, the next 292 are so-called
"garbage" digits ([[DRAGON]]). And finally we have 6 meaningless zeros after a
possibly localized decimal point.

Formatting of small floating-point numbers is even less useful. For example:

```c++
std::cout << std::to_string(-1e-7);
```

prints

```
-0.000000
```

In fact almost half of floating-point numbers are formatted as zero and there is
a precision loss or garbage digit output in many other cases.

Unfortunately issues with floating-point overloads of `std::to_string` have not
been discussed in the paper that proposed this facility ([[N1803]], [[N2408]]).
However, they been brought up as early as 2015 in a mailing list discussion
([[STD_DISCUSSION]]) which proposed deprecating floating-point overloads of
`std::to_string` but no paper came out of that.

Proposal {#proposal}
========

Redefine `std::to_string` in terms of `std::format` which in turn uses
`std::to_chars` making more explicit the fact that integral overloads are
unlocalized and changing the format of floating-point overloads to also be
unlocalized and use the shortest decimal representation.

The following table shows the changes in output for the following code:
<!-- https://godbolt.org/z/5ec5s5KdM -->

```
setlocale(LC_ALL, "C");
auto output = std::to_string(input);
```
<table style="text-align: right;">
<thead>
<tr>
<td>`input`
<td colspan="2">`output`
</tr>
<tr>
<td>
<td>**before**
<td>**after**
</tr>
</thead>
<tr>
  <td>42
  <td>42
  <td>42
</tr>
<tr>
  <td>0.42
  <td>0.420000
  <td>0.42
</tr>
<tr>
  <td>-1e-7
  <td>-0.000000
  <td>-1e-7
</tr>
<tr>
  <td>1.7976931348623157e+308
  <td style="max-width: 200px; word-wrap: break-word;">179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  <td>1.7976931348623157e+308
</tr>
</table>

and similarly with the global C locale set:
```
setlocale(LC_ALL, "uk_UA.UTF-8");
auto output = std::to_string(input);
```

<table style="text-align: right;">
<thead>
<tr>
<td>`input`
<td colspan="2">`output`
</tr>
<tr>
<td>
<td>**before**
<td>**after**
</tr>
</thead>
<tr>
  <td>12345
  <td>12345
  <td>12345
</tr>
<tr>
  <td>1234.5
  <td>1234,500000
  <td>1234.5
</tr>
</table>

Impact on existing code {#impact}
=======================

This change will affect the output of `std::to_string` with floating-point
arguments. In most cases it will result in a more precise and/or shorter output.
In cases where the C locale is explicitly set the decimal point will no longer
be localized.

Implementation {#impl}
==============

{fmt} implements proposed changes in `fmt::to_string`.

Wording {#wording}
=======

Add an entry for `__cpp_lib_to_string` to section "Header `<version>` synopsis
[[version.syn](
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4910.pdf#subsection.17.3.2)]",
in a place that respects the table’s current alphabetic order:

<pre>
<ins>#define __cpp_lib_to_string **placeholder**	// also in &lt;string&gt;</ins>
</pre>

Modify subsection "Numeric conversions [[string.conversions](
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4910.pdf#subsection.23.4.5)]":

```
string to_string(int val);
string to_string(unsigned val);
string to_string(long val);
string to_string(unsigned long val);
string to_string(long long val);
string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);
```

<del>
7 *Returns:* Each function returns a string object holding the character
representation of the value of its argument that would be generated by calling
`sprintf(buf, fmt, val)` with a format specifier of `"%d"`, `"%u"`, `"%ld"`,
`"%lu"`, `"%lld"`, `"%llu"`, `"%f"`, `"%f"`, or `"%Lf"`, respectively, where
`buf` designates an internal character buffer of sufficient size.
</del>
<p>
<ins>
7 *Returns:* `format("{}", val)`.
</ins>

```
wstring to_wstring(int val);
wstring to_wstring(unsigned val);
wstring to_wstring(long val);
wstring to_wstring(unsigned long val);
wstring to_wstring(long long val);
wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
wstring to_wstring(double val);
wstring to_wstring(long double val);
```

<del>
14 *Returns:* Each function returns a `wstring` object holding the character
representation of the value of its argument that would be generated by calling
`swprintf(buf, buffsz, fmt, val)` with a format specifier of `L"%d"`, `L"%u"`,
`L"%ld"`, `L"%lu"`, `L"%lld"`, `L"%llu"`, `L"%f"`, `L"%f"`, or `L"%Lf"`,
respectively, where `buf` designates an internal character buffer of sufficient
size `buffsz`.
</del>
<p>
<ins>
14 *Returns:* `format(L"{}", val)`.
</ins>

Add to Annex C (informative) Compatibility
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4910.pdf#page=1786">[diff]</a>
the following new subclause:

<p>
<ins>
**C.? C++ and ISO C++ 2026** [diff.cpp23]
</ins>
<p>
<ins>
This subclause lists the differences between C++ and ISO C++ 2023 (ISO/IEC
14882:2023, Programming Languages — C++), by the chapters of this document.
</ins>

<p>
<ins>
**C.?.1 Clause 23: strings library** [diff.cpp23.strings]
</ins>
<p>
<ins>
**Affected subclauses:** 23.4<br>
**Change:** Output of floating-point overloads of `to_string` and `to_wstring`.<br>
**Rationale:** Prevent loss of information and improve consistentcy with other
formatting facilities.<br>
**Effect on original feature:** `to_string` and `to_wstring` function calls that
take floating-point arguments may produce a different output. For example:
</ins>
<pre>
<ins>
auto s = std::to_string(1e-7); // "1e-7"
                               // previously "0.000000" with '.' possibly
                               // changed according to the global C locale
</ins>
</pre>

<pre class=biblio>
{
  "N1803": {
    "title": "Simple Numeric Access",
    "authors": ["Pete Becker"],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1803.html"
  },
  "N2408": {
    "title": "Simple Numeric Access Revision 2",
    "authors": ["Pete Becker"],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2408.html"
  },
  "STD_DISCUSSION": {
    "title": "Deprecate to_string() for floating point types?",
    "href": "https://groups.google.com/a/isocpp.org/g/std-discussion/c/6xhWgsEuvPo"
  },
  "N4910": {
    "title":
    "Working Draft, Standard for Programming Language C++",
    "authors": ["Thomas Köppe"],
    "href": "https://wg21.link/n4910"
  },
  "DRAGON": {
    "title": "How to Print Floating-Point Numbers Accurately",
    "authors": ["Guy L. Steele Jr.", "Jon L White"],
    "href": "https://fmt.dev/papers/p372-steele.pdf"
  }
}
</pre>
