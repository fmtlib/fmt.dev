<pre class='metadata'>
Title: Text Parsing
Shortname: P1729
Revision: 3
Audience: LEWG, SG9, SG16
Status: D
Group: WG21
URL: http://wg21.link/P1729R2
Editor: Elias Kosunen, isocpp@eliaskosunen.com
Editor: Victor Zverovich, victor.zverovich@gmail.com
Abstract:
  This paper discusses a new text parsing facility to complement the text
  formatting functionality of <code>std::format</code>, proposed in [[P0645]].
Date: 2023-08-05
Markup Shorthands: markdown yes
Max ToC Depth: 2
</pre>

Revision history {#history}
================

Changes since R2 {#history-since-r2}
----------------

* Default `CharT` to `char` in `scanner` for consistency with `formatter`.
* Clarify handling of literal characters.

Changes since R1 {#history-since-r1}
----------------

 * Thoroughly describe the design
 * Add examples
 * Add specification (synopses only)
 * Design changes:
    * Return an `expected` containing a `tuple` from `std::scan`, instead of using output parameters
    * Make `std::scan` take a range instead of a `string_view`
    * Remove support for partial successes

Introduction {#introduction}
============

With the introduction of `std::format` [[P0645]],
standard C++ has a convenient, safe, performant, extensible,
and elegant facility for text formatting,
over `std::ostream` and the `printf`-family of functions.
The story is different for simple text parsing: the standard only
provides `std::istream` and the `scanf` family, both of which have issues.
This asymmetry is also arguably an inconsistency in the standard library.

According to [[CODESEARCH]], a C and C++ codesearch engine based on the ACTCD19
dataset, there are 389,848 calls to `sprintf` and 87,815 calls to `sscanf` at
the time of writing. So although formatted input functions are less popular than
their output counterparts, they are still widely used.

The lack of a general-purpose parsing facility based on format strings has been
raised in [[P1361]] in the context of formatting and parsing of dates and times.

This paper explores the possibility of adding a symmetric parsing facility,
to complement the `std::format` family, called `std::scan`.
This facility is based on the same design principles and
shares many features with `std::format`.

Examples {#examples}
========

Basic example {#example-basic}
-------------

```c++
if (auto result = std::scan<std::string, int>("answer = 42", "{} = {}")) {
  //                        ~~~~~~~~~~~~~~~~   ~~~~~~~~~~~    ~~~~~~~
  //                          output types        input        format
  //                                                           string

  const auto& [key, value] = result->values();
  //           ~~~~~~~~~~
  //            scanned
  //            values

  // result == true
  // result.begin() points to the end of the given input (the null terminator)
  // key == "answer"
  // value == 42
} else {
  // We'll end up here if we had an error
  // Inspect the returned scan_error with result.error()
}
```

Reading multiple values at once {#example-multiple}
-------------------------------

```c++
auto input = "25 54.32E-1 Thompson 56789 0123";

auto result = std::scan<int, float, string_view, int, float, int>(
  input, "{:d}{:f}{:9}{:2i}{:g}{:o}");

// result is a std::expected, operator-> will throw if it doesn't contain a value
auto [i, x, str, j, y, k] = result->values();

// i == 25
// x == 54.32e-1
// str == "Thompson"
// j == 56
// y == 789.0
// k == 0123
```

Reading from an arbitrary range {#example-range}
-------------------------------

```c++
std::string input{"123 456"};
if (auto result = std::scan<int>(std::views::reverse(input), "{}")) {
  // If only a single value is returned, it can be inspected with result->value()
  // result->value() == 654
}
```

Reading multiple values in a loop {#example-loop}
---------------------------------

```c++
std::vector<int> read_values;
std::ranges::forward_range auto range = ...;
auto it = range.begin();

while (auto result = std::scan<int>(std::ranges::subrange{it, range.end()}, "{}")) {
  read_values.push_back(result->value());
  it = result->begin();
}
```

Alternative error handling {#example-alt-error}
--------------------------

<pre highlight=cpp>
// Since std::scan returns a std::expected,
// its monadic interface can be used

auto result = std::scan&lt;int&gt;(..., "{}")
  .transform([](auto result) {
    return result.value();
  });
auto num = *result;

// With [<a data-link-type=biblio data-biblio-type=informative>P2561</a>]:
auto num = std::scan&lt;int&gt;(..., "{}").try?.value();
</pre>

Scanning an user-defined type {#example-userdef}
-----------------------------

```c++
struct mytype {
  int a{}, b{};
};

template <>
struct std::scanner<mytype> : std::scanner<std::string> {
  template <typename Context>
  auto scan(mytype& val, Context& ctx) const
      -> std::expected<typename Context::iterator, std::scan_error> {
    return std::scan<int, int>(ctx.range(), "[{}, {}]")
      .transform([&val](const auto& result) {
        std::tie(val.a, val.b) = result.values();
        return result.begin();
      });
  }
};

auto result = std::scan<mytype>("[123, 456]", "{}");
// result->value().a == 123
// result->value().b == 456
```

Design {#design}
======

The new parsing facility is intended to complement the existing C++ I/O streams
library, integrate well with the chrono library, and provide an API similar to
`std::format`. This section discusses the major features of its design.

Overview {#overview}
--------

The main user-facing part of the library described in this paper,
is the function template `std::scan`, the input counterpart of `std::format`.
The signature of `std::scan` is as follows:

```c++
template <class... Args, scannable_range<char> Range>
auto scan(Range&& range, format_string<Args...> fmt)
  -> expected<scan_result<ranges::borrowed_iterator_t<Range>, Args...>, scan_error>;

template <class... Args, scannable_range<wchar_t> Range>
auto scan(Range&& range, wformat_string<Args...> fmt)
  -> expected<scan_result<ranges::borrowed_iterator_t<Range>, Args...>, scan_error>;
```

`std::scan` reads values of type `Args...` from the `range` it's given,
according to the instructions given to it in the format string, `fmt`.
`std::scan` returns a `std::expected`, containing either a `scan_result`, or a `scan_error`.
The `scan_result` object contains an iterator, which points to the beginning of the unparsed input,
and a `tuple` of `Args...`, containing the scanned values.

Format strings {#format-strings}
--------------

As with `printf`, the `scanf` syntax has the advantage of being familiar to many
programmers. However, it has similar limitations:

  * Many format specifiers like `hh`, `h`, `l`, `j`, etc. are used only to
    convey type information. They are redundant in type-safe parsing and would
    unnecessarily complicate specification and parsing.

  * There is no standard way to extend the syntax for user-defined types.

  * Using `'%'` in a custom format specifier poses difficulties, e.g. for
    `get_time`-like time parsing.

Therefore, we propose a syntax based on `std::format` and [[PARSE]]. This syntax
employs `'{'` and `'}'` as replacement field delimiters instead of `'%'`. It
will provide the following advantages:

  * An easy-to-parse mini-language focused on the data format rather than
    conveying the type information
  * Extensibility for user-defined types
  * Positional arguments
  * Support for both locale-specific and locale-independent parsing (see
    [[#locales]])
  * Consistency with `std::format`.

At the same time, most of the specifiers will remain quite similar to the ones
in `scanf`, which can simplify a, possibly automated, migration.

Maintaining similarity with `scanf`, for any literal non-whitespace character in
the format string, an identical character is consumed from the input range.
For whitespace characters, all available whitespace characters are consumed.
Whether a character is a whitespace character is determined as if by calling
`std::isspace` with the current or passed locale if using the `L` format
specifier. Otherwise, the behavior is locale-independent (as if by using
`std::locale::classic()`).

<div class=example>
```c++
auto r0 = std::scan<char>("abcd", "ab{}d"); // r0->value() == 'c'

auto r1 = std::scan<string, string>("abc \n def", "{} {}");
const auto& [s1, s2] = r1->values(); // s1 == "abc", s2 == "def"
```
</div>

As mentioned above, the format string syntax consists of replacement fields
delimited by curly brackets (`{` and `}`).
Each of these replacement fields corresponds to a value to be scanned from the input range.
The replacement field syntax is quite similar to `std::format`, as can be seen in the table below.
Elements that are in one but not the other are highlighted.

<table>
<thead>
<tr>
<th>`scan` replacement field syntax</th>
<th>`format` replacement field syntax</th>
</tr>
</thead>

<tbody>
<tr>
<td>
<pre>
replacement-field ::= '{' [arg-id] [':' format-spec] '}'
format-spec       ::= [fill-and-align]
                      
                      [width]
                      ['L'] [type]
fill-and-align    ::= [fill] align
fill              ::= <i>any character other than</i>
                      '{' <i>or</i> '}'
align             ::= <i>one of</i> '<' '>' '^'

width             ::= positive-integer



type              ::= <i>one of</i>
                      'a' 'A'
                      'b' 'B'
                      'c'
                      'd'
                      'e' 'E'
                      'f' 'F'
                      'g' 'G'
                      'o'
                      'p'
                      's'
                      'x' 'X'
                      '?'
                      <ins>'i'</ins>
                      <ins>'u'</ins>
</pre>
<!--
scnlib also has types:
 * 'rnn', 'Rnn' for arbitrary base (r = radix)
 * 'U' for Unicode code point
 * '[...]' for scanf-like set of characters
-->
</td>

<td>
<pre>
replacement-field ::= '{' [arg-id] [':' format-spec] '}'
format-spec       ::= [fill-and-align]
                      <ins>[sign] ['#'] ['0']</ins>
                      [width] <ins>[precision]</ins>
                      ['L'] [type]
fill-and-align    ::= [fill] align
fill              ::= <i>any character other than</i>
                      '{' <i>or</i> '}'
align             ::= <i>one of</i> '<' '>' '^'
<ins>sign              ::= <i>one of</i> '+' '-' ' '</ins>
width             ::= positive-integer
                      <ins><i>OR</i> '{' [arg-id] '}'</ins>
<ins>precision         ::= '.' nonnegative-integer
                      <i>OR</i> '.' '{' [arg-id] '}'</ins>
type              ::= <i>one of</i>
                      'a' 'A'
                      'b' 'B'
                      'c'
                      'd'
                      'e' 'E'
                      'f' 'F'
                      'g' 'G'
                      'o'
                      'p'
                      's'
                      'x' 'X'
                      '?'


</pre>
</td>
</tr>
</tbody>
</table>

Format string specifiers {#format-string-specifiers}
------------------------

Below is a somewhat detailed description of each of the specifiers
in a `std::scan` replacement field.
This design attempts to maintain decent compatibility with `std::format`
whenever practical, while also bringing in some ideas from `scanf`.

<h4 id="fmt-arg-id">Manual indexing</h4>

<pre>
replacement-field ::= '{' [arg-id] [':' format-spec] '}'
</pre>

Like `std::format`, `std::scan` supports manual indexing of
arguments in format strings. If manual indexing is used,
all of the argument indices have to be spelled out.
The same index can only be used once.

<div class=example>
```c++
auto r = std::scan<int, int, int>("0 1 2", "{1} {0} {2}");
auto [i0, i1, i2] = r->values();
// i0 == 1, i1 == 0, i2 == 2
```
</div>

<h4 id="fmt-fill-and-align">Fill and align</h4>

<pre>
fill-and-align  ::= [fill] align
fill            ::= <i>any character other than</i>
                    '{' <i>or</i> '}'
align           ::= <i>one of</i> '<' '>' '^'
</pre>

The fill and align options are valid for all argument types.
The fill character is denoted by the `fill`-option, or if it is absent,
the space character `' '`.
The fill character can be any single Unicode scalar value.
The field width is determined the same way as it is for `std::format`.

If an alignment is specified, the value to be parsed is assumed to be properly
aligned with the specified fill character.

If a field width is specified, it will be the maximum number of characters
to be consumed from the input range.
In that case, if no alignment is specified, the default alignment for the type
is considered (see `std::format`).

For the `'^'` alignment, the number of fill characters needs to be
the same as if formatted with `std::format`:
`floor(n/2)` characters before, `ceil(n/2)` characters after the value,
where `n` is the field width.
If no field width is specified, an equal number of alignment characters on both
sides are assumed.

This spec is compatible with `std::format`,
i.e., the same format string (wrt. fill and align)
can be used with both `std::format` and `std::scan`,
with round-trip semantics.

Note: For format type specifiers other than `'c'`
(default for `char` and `wchar_t`, can be specified for `basic_string` and `basic_string_view`),
leading whitespace is skipped regardless of alignment specifiers.

<div class=example>
```c++
auto r0 = std::scan<int>("   42", "{}"); // r0->value() == 42, r0->begin() == ""
auto r1 = std::scan<char>("   x", "{}"); // r1->value() == ' ', r1->begin() == "  x"
auto r2 = std::scan<char>("x   ", "{}"); // r2->value() == 'x', r2->begin() == "   "

auto r3 = std::scan<int>("    42", "{:6}");  // r3->value() == 42, r3->begin() == ""
auto r4 = std::scan<char>("x     ", "{:6}"); // r4->value() == 'x', r4->begin() == ""

auto r5 = std::scan<int>("***42", "{:*>}");  // r5->value() == 42
auto r6 = std::scan<int>("***42", "{:*>5}"); // r6->value() == 42
auto r7 = std::scan<int>("***42", "{:*>4}"); // r7->value() == 4
auto r8 = std::scan<int>("42", "{:*>}");     // r8->value() == 42
auto r9 = std::scan<int>("42", "{:*>5}");    // ERROR (mismatching field width)

auto rA = std::scan<int>("42***", "{:*<}");  // rA->value() == 42, rA->begin() == ""
auto rB = std::scan<int>("42***", "{:*<5}"); // rB->value() == 42, rB->begin() == ""
auto rC = std::scan<int>("42***", "{:*<4}"); // rC->value() == 42, rC->begin() == "*"
auto rD = std::scan<int>("42", "{:*<}");     // rD->value() == 42
auto rE = std::scan<int>("42", "{:*<5}");    // ERROR (mismatching field width)

auto rF = std::scan<int>("42", "{:*^}");    // rF->value() == 42, rF->begin() == ""
auto rG = std::scan<int>("*42*", "{:*^}");  // rG->value() == 42, rG->begin() == ""
auto rH = std::scan<int>("*42**", "{:*^}"); // rH->value() == 42, rH->begin() == "*"
auto rI = std::scan<int>("**42*", "{:*^}"); // ERROR (not enough fill characters after value)

auto rJ = std::scan<int>("**42**", "{:*^6}"); // rJ->value() == 42, rJ->begin() == ""
auto rK = std::scan<int>("*42**", "{:*^5}");  // rK->value() == 42, rK->begin() == ""
```
</div>

Note: This behavior, while compatible with `std::format`,
is very complicated, and potentially hard to understand for users.
Since `scanf` doesn't support parsing of fill characters this way,
it's possible to leave this feature out for v1, and come back to this later:
it's not a breaking change to add formatting specifiers that add new behavior.

<h4 id="fmt-sign-hash-0">Sign, `#`, and `0`</h4>

<pre>
format-spec ::= ...
                <del>[sign] ['#'] ['0']</del>
                ...
<del>sign        ::= <i>one of</i> '+' '-' ' '</del>
</pre>

These flags would have no effect in `std::scan`, so they are disabled.
Signs (both `+` and `-`), base prefixes, trailing decimal points, and leading zeroes
are always allowed for arithmetic values.
Disabling them would be a bad default for a higher-level facility
like `std::scan`, so flags explicitly enabling them are not needed.

Note: This is incompatible with `std::format` format strings.

<h4 id="fmt-width-precision">Width and precision</h4>

<pre>
width     ::= positive-integer
              <del><i>OR</i> '{' [arg-id] '}'</del>
<del>precision ::= '.' nonnegative-integer
              <i>OR</i> '.' '{' [arg-id] '}'</del>
</pre>

The width specifier is valid for all argument types.
The meaning of this specifier somewhat deviates from `std::format`.
The width and precision specifiers of it are somewhat combined into
a single width specifier in `std::scan`.
This specifier indicates the expected field width of the value to be
scanned, taking into account possible fill characters used for alignment.
If no fill characters are expected, it specifies the maximum width for the field.

For compatibility with `std::format`,
the width specifier is in <i>field width units</i>,
which is specified to be 1 per Unicode (extended) grapheme cluster,
except some grapheme clusters are 2 ([format.string.std] &para; 13):

> For a sequence of characters in UTF-8, UTF-16, or UTF-32,
> an implementation should use as its field width the sum of the field widths
> of the first code point of each extended grapheme cluster.
> Extended grapheme clusters are defined by UAX #29 of the Unicode Standard.
> The following code points have a field width of 2:
>
> * any code point with the East_Asian_Width="W" or East_Asian_Width="F"
>     Derived Extracted Property as described by UAX #44 of the Unicode Standard
> * U+4dc0 – U+4dff (Yijing Hexagram Symbols)
> * U+1f300 – U+1f5ff (Miscellaneous Symbols and Pictographs)
> * U+1f900 – U+1f9ff (Supplemental Symbols and Pictographs)
>
> The field width of all other code points is 1.
>
> For a sequence of characters in neither UTF-8, UTF-16, nor UTF-32, the field width is unspecified.

This essentially maps 1 field width unit = 1 user perceived character.
It should be noted, that with this definition, grapheme clusters like emoji have a field width of 2.
This behavior is present in `std::format` today, but can potentially be surprising to users.

<div class=note>
Other options can be considered, if compatibility with `std::format` can be set aside.
These options include:

 * Plain bytes or code units
 * Unicode code points
 * Unicode (extended) grapheme clusters
 * `std::format`-like field width units, except only looking at code points, instead of grapheme clusters
 * Exclusively using UAX #11 (East Asian Width) widths

</div>

Specifying the width with another argument, like in `std::format`, is disallowed.

<h4 id="fmt-localized">Localized (`L`)</h4>

<pre>
format-spec ::= ...
                ['L']
                ...
</pre>

Enables scanning of values in locale-specific forms.

 * For integer types, allows for digit group separator characters,
    equivalent to `numpunct::thousands_sep` of the used locale.
    If digit group separator characters are used, their grouping
    must match `numpunct::grouping`.

 * For floating-point types, the same as above.
    In addition, the locale-specific radix separator character is used,
    from `numpunct::decimal_point`.

 * For `bool`, the textual representation uses the appropriate strings
    from `numpunct::truename` and `numpunct::falsename`.

<h4 id="fmt-type-string">Type specifiers: strings</h4>

<table>
<tr>
<th>Type
<th>Meaning
</tr>

<tr>
<td>none,&nbsp;`s`
<td>Copies from the input until a whitespace character is encountered.
</tr>

<tr>
<td>`?`
<td>Copies an escaped string from the input.
</tr>

<tr>
<td>`c`
<td>Copies from the input until the field width is exhausted.
Does not skip preceding whitespace.
Errors, if no field width is provided.
</tr>
</table>

<div class=note>
The `s` specifier is consistent with `std::istream` and `std::string`:
```c++
std::string word;
std::istringstream{"Hello world"} >> word;
// word == "Hello"

auto r = std::scan<string>("Hello world", "{:s}");
// r->value() == "Hello"
```
</div>

Note: The `c` specifier is consistent with `scanf`,
but is not supported for strings by `std::format`.

<h4 id="fmt-type-int">Type specifiers: integers</h4>

Integer values are scanned as if by using `std::from_chars`, except:

 * A positive `+` sign and a base prefix are always allowed to be present.
 * Preceding whitespace is skipped.

<table>
<tr>
<th>Type
<th>Meaning
</tr>

<tr>
<td>`b`, `B`
<td>`from_chars` with base 2. The base prefix is `0b` or `0B`.
</tr>

<tr>
<td>`o`
<td>`from_chars` with base 8. For non-zero values, the base prefix is `0`.
<!-- scnlib also allows for `0o` and 0O` -->
<!-- scnlib also supports flag `O`, but it doesn't make sense with octal numbers without a prefix containing a letter -->
</tr>

<tr>
<td>`x`, `X`
<td>`from_chars` with base 16. The base prefix is `0x` or `0X`.
</tr>

<tr>
<td>`d`
<td>`from_chars` with base 10. No base prefix.
</tr>

<tr>
<td>`u`
<td>`from_chars` with base 10. No base prefix. No `-` sign allowed.
</tr>

<tr>
<td>`i`
<td>Detect base from a possible prefix, default to decimal.
</tr>

<tr>
<td>`c`
<td>Copies a character from the input.
</tr>

<tr>
<td>none
<td>Same as `d`
</tr>
</table>

Note: The flags `u` and `i` are not supported by `std::format`.
These flags are consistent with `scanf`.

<h4 id="fmt-type-char">Type specifiers: `CharT`</h4>

<table>
<tr>
<th>Type
<th>Meaning
</tr>

<tr>
<td>none, `c`
<td>Copies a character from the input.
</tr>

<tr>
<td>`b`, `B`, `d`, `i`, `o`, `u`, `x`, `X`
<td>Same as for integers.
</tr>

<tr>
<td>`?`
<td>Copies an escaped character from the input.
</tr>
</table>

Note: This is not encoding or Unicode-aware.
Reading a `CharT` with the `c` type specifier
will just read a single code unit of type `CharT`.

<h4 id="fmt-type-bool">Type specifiers: `bool`</h4>

<table>
<tr>
<th>Type
<th>Meaning
</tr>

<tr>
<td>`s`
<td>Allows for textual representation, i.e. `true` or `false`
</tr>

<tr>
<td>`b`, `B`, `d`, `o`, `u`, `x`, `X`
<td>Allows for integral representation, i.e. `0` or `1`
</tr>

<tr>
<td>none
<td>Allows for both textual and integral representation: i.e. `true`, `1`, `false`, or `0`.
</tr>
</table>

<h4 id="fmt-type-float">Type specifiers: floating-point types</h4>

Similar to integer types,
floating-point values are scanned as if by using `std::from_chars`, except:

 * A positive `+` sign is always allowed to be present.
 * Preceding whitespace is skipped.

<table>
<tr>
<th>Type
<th>Meaning
</tr>

<tr>
<td>`a`, `A`
<td>`from_chars` with `chars_format::hex`, with `0x`/`0X`-prefix allowed.
</tr>

<tr>
<td>`e`, `E`
<td>`from_chars` with `chars_format::scientific`.
</tr>

<tr>
<td>`f`, `F`
<td>`from_chars` with `chars_format::fixed`.
</tr>

<tr>
<td>`g`, `G`
<td>`from_chars` with `chars_format::general`.
</tr>

<tr>
<td>none
<td>`from_chars` with `chars_format::general | chars_format::hex`, with `0x`/`0X`-prefix allowed.
</tr>
</table>

Ranges {#ranges}
------

We propose, that `std::scan` would take a range as its input.
This range should satisfy the requirements of `std::ranges::forward_range` to
enable look-ahead, which is necessary for parsing.

```c++
template <class Range, class CharT>
concept scannable_range =
  ranges::forward_range<Range> && same_as<ranges::range_value_t<Range>, CharT>;
```

For a range to be a `scannable_range`, its character type (range `value_type`, code unit type)
needs to also be correct, i.e. it needs to match the character type of the format string.
Mixing and matching character types between the input range and the format string is not supported.

<div class=example>
```c++
scan<int>("42", "{}");   // OK
scan<int>(L"42", L"{}"); // OK
scan<int>(L"42", "{}");  // Error: wchar_t\[N] is not a scannable_range<char>
```
</div>

It should be noted, that standard range facilities related to iostreams, namely
`std::istreambuf_iterator`, model `input_iterator`.
Thus, they can't be used with `std::scan`, and therefore, for example,
`stdin`, can't be read directly using `std::scan`.
The reference implementation deals with this by providing a range type, that wraps a
`std::basic_istreambuf`, and provides a `forward_range`-compatible interface to it.
At this point, this is deemed out of scope for this proposal.

To prevent excessive code bloat, implementations are encouraged to type-erase the range
provided to `std::scan`, in a similar fashion as inside `std::format_to`.
This can be achieved with something similar to `any_view` from Range-v3.
The reference implementation does something similar to this, inside the implementation of `vscan`,
where ranges that are both contiguous and sized are internally passed along as `string_view`s,
and as type-erased `forward_range`s otherwise.

It should be noted, that if the range is not type-erased, the library internals need to be exposed
to the user (in a header), and be instantiated for every different kind of range type the user uses.

Argument passing, and return type of `scan` {#argument-passing}
-------------------------------------------

In an earlier revision of this paper, output parameters were used to return the scanned values
from `std::scan`. In this revision, we propose returning the values instead, wrapped in an `expected`.

```c++
// R2 (current)
auto result = std::scan<int>(input, "{}");
auto [i] = result->values();
// or:
auto i = result->value();

// R1 (previous)
int i;
auto result = std::scan(input, "{}", i);
```

The rationale behind this change is as follows:

 - It was easy to accidentally use uninitialized values (as evident by the example above).
    In this revision, the values can only be accessed when the operation is successful.

 - Modern C++ API design principles favor return values over output parameters.

 - The earlier design was conceived at a time, when C++17 support and usage wasn't as prevalent as it is today.
    Back then, the only way to use a return-value API was through `std::tie`, which wasn't ergonomic.
 
 - Previously, there were real performance implications when using complicated tuples,
    both at compile-time and runtime. These concerns have since been alleviated, as compiler technology has improved.

<h4 id="return-type-alternatives">Design alternatives</h4>

As proposed, `std::scan` returns an `expected`, containing either an iterator and a tuple, or a `scan_error`.

An alternative could be returning a `tuple`, with a result object as its first (0th) element, and the parsed values occupying the rest.
This would enable neat usage of structured bindings:

```c++
// NOT PROPOSED, design alternative
auto [r, i] = std::scan<int>("42", "{}");
```

However, there are two possible issues with this design:

 1. It's easy to accidentally skip checking whether the operation succeeded, and access the scanned values regardless.
    This could be a potential security issue (even though the values would always be at least value-initialized, not default-initialized).
    Returning an expected forces checking for success.

 2. The numbering of the elements in the returned tuple would be off-by-one compared to the indexing used in format strings:
    ```c++
    auto r = std::scan<int>("42", "{0}");
    // std::get<0>(r) refers to the result object
    // std::get<1>(r) refers to {0}
    ```

For the same reason as enumerated in 2. above, the `scan_result` type as proposed doesn't follow the tuple protocol, so that structured bindings can't be used with it:

```c++
// NOT PROPOSED
auto result = std::scan<int>("42", "{0}");
// std::get<0>(*result) would refer to the iterator
// std::get<1>(*result) would refer to {0}
```

Error handling {#error-handling}
--------------

Contrasting with `std::format`, this proposed library communicates errors with return values,
instead of throwing exceptions. This is because error conditions are expected to be much
more frequent when parsing user input, as opposed to text formatting.
With the introduction of `std::expected`, error handling using return values is also more ergonomic than before,
and it provides a vocabulary type we can use here, instead of designing something novel.

`std::scan_error` holds an enumerated error code value, and a message string.
The message is used in the same way as the message in `std::exception`:
it gives more details about the error, but its contents are unspecified.

```c++
// Not a specification, just exposition
class scan_error {
public:
  enum code_type {
    good,

    // EOF:
    // tried to read from an empty range,
    // or the input ended unexpectedly.
    // Naming alternative: end_of_input
    end_of_range,

    invalid_format_string,

    invalid_scanned_value,

    value_out_of_range
  };

  constexpr scan_error() = default;
  constexpr scan_error(code_type, const char*);

  constexpr explicit operator bool() const noexcept;

  constexpr code_type code() const noexcept;
  constexpr const char* msg() const;
};
```

<h4 id="error-handling-discussion">Design discussion</h4>

The reason why we propose adding the type `std::scan_error` instead of just using `std::errc` is,
that we want to avoid losing information. The enumerators of `std::errc` are insufficient for
this use, as evident by the table below: there are no clear one-to-one mappings between `scan_error::code_type`
and `std::errc`, but `std::errc::invalid_argument` would need to cover a lot of cases.

The `const char*` in `scan_error` is extremely useful for user code, for use in logging and debugging.
Even with the `scan_error::code_type` enumerators, more information is often needed, to isolate any possible problem.

Possible mappings from `scan_error::code_type` to `std::errc` could be:

<table>
<thead>
<tr>
<th>`scan_error::code_type`
<th>`errc`
</tr>
</thead>

<tbody>

<tr>
<td>`scan_error::good`
<td>`std::errc{}`
</tr>

<tr>
<td>`scan_error::end_of_range`
<td rowspan="3" style="vertical-align: middle">`std::errc::invalid_argument`
</tr>

<tr>
<td>`scan_error::invalid_format_string`
</tr>

<tr>
<td>`scan_error::invalid_scanned_value`
</tr>

<tr>
<td>`scan_error::value_out_of_range`
<td>`std::errc::result_out_of_range`
</tr>

</tbody>
</table>

There are multiple dimensions of design decisions to be done here:
 
<ol>

<li><b>Should `scan_error` use a custom enumeration?</b>
   1. <b>Yes.</b> (currently proposed, our preference)
   2. <b>No, use `std::errc`.</b> Loses precision in error codes

<li><b>Should `scan_error` contain a message?</b>
   1. <b>Yes, a `const char*`</b>. (currently proposed, weak preference)
   2. <b>Yes, a `std::string`.</b> Potentially more expensive.
   3. <b>No.</b> Worse user experience for loss of diagnostic information

</ol>

Binary footprint and type erasure {#binary-footprint}
---------------------------------

We propose using a type erasure technique to reduce the per-call binary code size.
The scanning function that uses variadic templates can be implemented as a
small inline wrapper around its non-variadic counterpart:

<pre highlight=cpp>
template&lt;scannable_range&lt;char&gt; Range&gt;
auto vscan(Range&& range,
           string_view fmt,
           scan_args_for&lt;Range&gt; args)
  -> expected&lt;ranges::borrowed_iterator_t&lt;Range&gt;, scan_error&gt;;

template &lt;typename... Args, scannable_range&lt;char&gt; SourceRange&gt;
auto scan(SourceRange&& source, format_string&lt;Args...&gt; format)
    -> expected&lt;scan_result&lt;ranges::borrowed_iterator_t&lt;SourceRange&gt;, Args...&gt;, scan_error&gt; {
  auto args = make_scan_args&lt;SourceRange, Args...&gt;();
  auto result = vscan(std::forward&lt;SourceRange&gt;(range), format, args);
  return make_scan_result(std::move(result), std::move(args));
}
</pre>

As shown in [[P0645]] this dramatically reduces binary code size, which will make
`scan` comparable to `scanf` on this metric.

`make_scan_args` type erases the arguments that are to be scanned.
This is similar to `std::make_format_args`, used with `std::format`.

Note: This implementation of `std::scan` is more complicated
compared to `std::format`, which can be described as a one-liner calling `std::vformat`.
This is because the <code><i>scan-arg-store</i></code> returned by `make_scan_args`
needs to outlive the call to `vscan`, and then be converted to a `tuple` and returned from `scan`.
Whereas with `std::format`, the <code><i>format-arg-store</i></code> returned by `std::make_format_args`
is immediately consumed by `std::vformat`, and not used elsewhere.

Safety {#safety}
------

`scanf` is arguably more unsafe than `printf` because
`__attribute__((format(scanf, ...)))` ([[ATTR]]) implemented by GCC and Clang
doesn't catch the whole class of buffer overflow bugs, e.g.

```c++
char s[10];
std::sscanf(input, "%s", s); // s may overflow.
```

Specifying the maximum length in the format string above solves the issue but is
error-prone, especially since one has to account for the terminating null.

Unlike `scanf`, the proposed facility relies on variadic templates instead of
the mechanism provided by `<cstdarg>`. The type information is captured
automatically and passed to scanners, guaranteeing type safety and making many of
the `scanf` specifiers redundant (see [[#format-strings]]). Memory management is
automatic to prevent buffer overflow errors.

Extensibility {#extensibility}
-------------

We propose an extension API for user-defined types similar to `std::formatter`,
used with `std::format`. It separates format string processing and parsing, enabling
compile-time format string checks, and allows extending the format specification
language for user types. It enables scanning of user-defined types.

```c++
auto r = scan<tm>(input, "Date: {0:%Y-%m-%d}");
```

This is done by providing a specialization of `scanner` for `tm`:

```c++
template <>
struct scanner<tm> {
  constexpr auto parse(scan_parse_context& ctx)
    -> expected<scan_parse_context::iterator, scan_error>;

  template <class ScanContext>
  auto scan(tm& t, ScanContext& ctx) const
    -> expected<typename ScanContext::iterator, scan_error>;
};
```

The `scanner<tm>::parse` function parses the `format-spec` portion of the format
string corresponding to the current argument, and `scanner<tm>::scan` parses the
input range `ctx.range()` and stores the result in `t`.

An implementation of `scanner<T>::scan` can potentially use the istream extraction
`operator>>` for user-defined type `T`, if available. 

Locales {#locales}
-------

As pointed out in [[N4412]]:

> There are a number of communications protocol frameworks in use that employ
> text-based representations of data, for example XML and JSON. The text is
> machine-generated and machine-read and should not depend on or consider the
> locales at either end.

To address this, `std::format` provided control over the use of locales. We propose
doing the same for the current facility by performing locale-independent parsing
by default and designating separate format specifiers for locale-specific ones.
In particular, locale-specific behavior can be opted into by using the `L`
format specifier, and supplying a `std::locale` object.

Performance {#performance}
-----------

The API allows efficient implementation that minimizes virtual function calls
and dynamic memory allocations, and avoids unnecessary copies. In particular,
since it doesn't need to guarantee the lifetime of the input across multiple
function calls, `scan` can take `string_view` avoiding an extra string copy
compared to `std::istringstream`. Since, in the default case, it also doesn't
deal with locales, it can internally use something like `std::from_chars`.

We can also avoid unnecessary copies required by `scanf` when parsing strings,
e.g.

```c++
auto r = std::scan<std::string_view, int>("answer = 42", "{} = {}");
```

This has lifetime implications similar to returning match objects in [[P1433]]
and iterators or subranges in the ranges library and can be mitigated in the same
way.

It should be noted, that as proposed, this library does not support
checking at compile-time, whether scanning a `string_view` would dangle, or
if it's possible at all (it's not possible to read a `string_view` from a non-`contiguous_range`).
This is the case, because the concept `scannable` is defined in terms of the scanned type `T`
and the input range character type `CharT`, not the type of the input range itself.

Integration with chrono {#chrono}
-----------------------

The proposed facility can be integrated with `std::chrono::parse` ([[P0355]])
via the extension mechanism, similarly to the integration between chrono and text
formatting proposed in [[P1361]]. This will improve consistency between parsing
and formatting, make parsing multiple objects easier, and allow avoiding dynamic
memory allocations without resolving to the deprecated `strstream`.

Before:
```
std::istringstream is("start = 10:30");
std::string key;
char sep;
std::chrono::seconds time;
is >> key >> sep >> std::chrono::parse("%H:%M", time);
```

After:
```
auto result = std::scan<std::string, std::chrono::seconds>("start = 10:30", "{0} = {1:%H:%M}");
const auto& [key, time] = result->values();
```

Note that the `scan` version additionally validates the separator.

Impact on existing code {#deep-impact}
-----------------------

The proposed API is defined in a new header and should have no impact on
existing code.

Existing work {#existing-work}
=============

[[SCNLIB]] is a C++ library that, among other things,
provides an interface similar to the one described in this paper.
As of the publication of this paper, the `dev`-branch of [[SCNLIB]]
contains the reference implementation for this proposal.

[[FMT]] has a prototype implementation of the proposal.

Future extensions {#future}
=================

To keep the scope of this paper somewhat manageable,
we've chosen to only include functionality we consider fundamental.
This leaves the design space open for future extensions and other proposals.
However, we are not categorically against exploring this design space,
if it is deemed critical for v1.

All of the possible future extensions described below are implemented in [[SCNLIB]].

Integration with `std::istream`s {#istream-integration}
--------------------------------

Today, in C++, standard I/O is largely done with iostreams, and not with ranges.
The library proposed in this paper doesn't support that use case well.
The proposed concept of `scannable_range` requires `forward_range`,
so facilities like `istreambuf_iterator`, which only models `input_iterator`,
can't be used.

Integration with iostreams is needed to enable working with files and `stdin`.
This can be worked around with something like `std::getline`,
and using its result with `std::scan`, but error recovery with that gets very tricky very fast.

A possible solution would be a more robust `istream_view`, that models at least `forward_range`,
either through caching the read characters in the view itself, or by utilizing the stream buffer.
[[SCNLIB]] implements this by providing a generic `caching_view`, which wraps an `input_range`
and a buffer, and provides an interface that models `bidirectional_range`.

`scanf`-like `[character set]` matching {#char-set-match}
---------------------------------------

`scanf` supports the `[` format specifier, which allows for matching for a set of accepted
characters. Unfortunately, because some of the syntax for specifying that set is
implementation-defined, the utility of this functionality is hampered.
Properly specified, this could be useful.

<div class=example>
```c++
auto r = scan<string>("abc123", "{:[a-zA-Z]}"); // r->value() == "abc", r->begin() == "123"
// Compare with:
char buf\[N];
sscanf("abc123", "%[a-zA-Z]", buf);

// ...

auto _ = scan<string>(..., "{:[^\n]}"); // match until newline
```
</div>

It should be noted, that while the syntax is quite similar, this is not a regular expression.
This syntax is intentionally way more limited, as is meant for simple character matching.

[[SCNLIB]] implements this syntax, providing support for matching single characters/code points
(`{:[abc]}`), code point ranges (`{:[a-z]}`), and regex-like wildcards (`{:[:alpha:]}` or `{:[\\w]})`.

Reading strings and chars of different width {#scan-transcode}
--------------------------------------------

In C++, we have character types other than `char` and `wchar_t`, too:
namely `char8_t`, `char16_t`, and `char32_t`.
Currently, this proposal only supports reading strings with the same
character type as the input range, and reading `wchar_t` characters from
narrow `char`-oriented input ranges, as does `std::format`.
`scanf` somewhat supports this with the `l`-flag (and the absence of one in `wscanf`).
Providing support for reading differently-encoded strings could be useful.

<div class=example>
```c++
// Currently supported:
auto r0 = scan<wchar_t>("abc", "{}");

// Not supported:
auto r1 = scan<char>(L"abc", L"{}");
auto r2 =
  scan<string, wstring, u8string, u16string, u32string>("abc def ghi jkl mno", "{} {} {} {} {}");
auto r3 =
  scan<string, wstring, u8string, u16string, u32string>(L"abc def ghi jkl mno", L"{} {} {} {} {}");
```
</div>

Scanning of ranges {#range-scanning}
------------------

Introduced in [[P2286]] for `std::format`, enabling the user to use `std::scan`
to scan ranges, could be useful.

Default values for scanned values {#default-values}
---------------------------------

Currently, the values returned by `std::scan` are value-constructed,
and assigned over if a value is read successfully.
It may be useful to be able to provide an initial value different from a value-constructed
one, for example, for preallocating a `string`, and possibly reusing it:

  ```c++
  string str;
  str.reserve(n);
  auto r0 = scan<string>(..., "{}", {std::move(str)});
  // ...
  r0->value().clear();
  auto r1 = scan<string>(..., "{}", {std::move(r0->value())});
  ```

Assignment suppression / discarding values {#discard}
------------------------------------------

`scanf` supports discarding scanned values with the `*` specifier in the format string.
[[SCNLIB]] provides similar functionality through a special type, `scn::discard`:

<div class=example>
```c++
int i;
scanf("%*d", &i);

auto r = scn::scan<scn::discard<int>>(..., "{}");
auto [_] = r->values();
```
</div>

Specification {#spec}
=============

At this point, only the synopses are provided.

Note the similarity with [[P0645]] (`std::format`) in some parts.

Add a new header, `<scan>`.

Header `<scan>` synopsis {#spec-header-synopsis}
------------------------

<pre highlight=cpp>
#include &lt;expected&gt;
#include &lt;format&gt;
#include &lt;ranges&gt;

namespace std {
  class scan_error;

  template&lt;class Iterator, class... Args&gt;
    class scan_result;

  template&lt;class Range, class CharT&gt;
    concept scannable_range =
      ranges::forward_range&lt;Range&gt; &&
      same_as&lt;ranges::range_value_t&lt;Range&gt;, CharT&gt;;

  template&lt;class Range, class...Args&gt;
    using scan_result_type = expected&lt;
      scan_result&lt;ranges::borrowed_iterator_t&lt;Range&gt;, Args...&gt;,
      scan_error&gt;;

  template&lt;class... Args, scannable_range&lt;char&gt; Range&gt;
    scan_result_type&lt;Range, Args...&gt; scan(Range&& range, format_string&lt;Args...&gt; fmt);

  template&lt;class... Args, scannable_range&lt;wchar_t&gt; Range&gt;
    scan_result_type&lt;Range, Args...&gt; scan(Range&& range, wformat_string&lt;Args...&gt; fmt);

  template&lt;class... Args, scannable_range&lt;char&gt; Range&gt;
    scan_result_type&lt;Range, Args...&gt; scan(const locale& loc, Range&& range, format_string&lt;Args...&gt; fmt);

  template &lt;class... Args, scannable_range&lt;wchar_t&gt; Range&gt;
    scan_result_type&lt;Range, Args...&gt; scan(const locale& loc, Range&& range, wformat_string&lt;Args...&gt; fmt);

  template&lt;class Range, class CharT&gt;
    class basic_scan_context;
  
  template&lt;class Context&gt;
    class basic_scan_args;

  template&lt;class Range&gt;
    using scan_args_for = basic_scan_args&lt;basic_scan_context&lt;
      <i>unspecified</i>,
      ranges::range_value_t&lt;Range&gt;&gt;&gt;;

  template&lt;class Range&gt;
  using vscan_result_type = expected&lt;ranges::borrowed_iterator_t&lt;Range&gt;, scan_error&gt;;

  template&lt;scannable_range&lt;char&gt; Range&gt;
  vscan_result_type&lt;Range&gt; vscan(Range&& range,
                                 string_view fmt,
                                 scan_args_for&lt;Range&gt; args);

  template&lt;scannable_range&lt;wchar_t&gt; Range&gt;
  vscan_result_type&lt;Range&gt; vscan(Range&& range,
                                 wstring_view fmt,
                                 scan_args_for&lt;Range&gt; args);

  template&lt;scannable_range&lt;char&gt; Range&gt;
  vscan_result_type&lt;Range&gt; vscan(const locale& loc,
                                 Range&& range,
                                 string_view fmt,
                                 scan_args_for&lt;Range&gt; args);

  template&lt;scannable_range&lt;wchar_t&gt; Range&gt;
  vscan_result_type&lt;Range&gt; vscan(const locale& loc,
                                 Range&& range,
                                 wstring_view fmt,
                                 scan_args_for&lt;Range&gt; args);

  template&lt;class T, class CharT = char&gt;
    struct scanner;

  template&lt;class T, class CharT&gt;
    concept scannable = <i>see below</i>;
  
  template&lt;class CharT&gt;
    using basic_scan_parse_context = basic_format_parse_context&lt;CharT&gt;;
  
  using scan_parse_context = basic_scan_parse_context&lt;char&gt;;
  using wscan_parse_context = basic_scan_parse_context&lt;wchar_t&gt;;

  template&lt;class Context&gt;
    class basic_scan_arg;

  template&lt;class Visitor, class Context&gt;
    decltype(auto) visit_scan_arg(Visitor&& vis, basic_scan_arg&lt;Context&gt; arg);
  
  template&lt;class Context, class... Args&gt;
    class <i>scan-arg-store</i>; // exposition only

  template&lt;class Range, class... Args&gt;
    constexpr <i>see below</i> make_scan_args();

  template&lt;class Iterator, class Context, class... Args&gt;
    expected&lt;scan_result&lt;Iterator, Args...&gt;, scan_error&gt;
      make_scan_result(expected&lt;Iterator, scan_error&gt;&& source,
                       <i>scan-arg-store</i>&lt;Context, Args...&gt;&& args);
}
</pre>

Class `scan_error` synopsis {#spec-scan-error-synopsis}
---------------------------

<pre highlight=cpp>
namespace std {
  class scan_error {
  public:
    enum code_type {
      good,
      end_of_range,
      invalid_format_string,
      invalid_scanned_value,
      value_out_of_range
    };

    constexpr scan_error() = default;
    constexpr scan_error(code_type error_code, const char* message);

    constexpr explicit operator bool() const noexcept;

    constexpr code_type code() const noexcept;
    constexpr const char* msg() const;

  private:
    code_type <i>code_</i>;      // exposition only
    const char* <i>message_</i>; // exposition only
  };
}
</pre>

Class template `scan_result` synopsis {#spec-scan-result-synopsis}
-------------------------------------

<pre highlight=cpp>
namespace std {
  template&lt;class Iterator, class... Args&gt;
  class scan_result {
  public:
    using iterator = Iterator;

    constexpr scan_result() = default;
    constexpr ~scan_result() = default;

    constexpr scan_result(iterator it, tuple&lt;Args...&gt;&& values);
    template&lt;class OtherIt, class... OtherArgs&gt;
      constexpr explicit(<i>see below</i>) scan_result(OtherIt&& it, tuple&lt;OtherArgs...&gt;&& values);

    constexpr scan_result(const scan_result&) = default;
    template&lt;class OtherIt, class... OtherArgs&gt;
      constexpr explicit(<i>see below</i>) scan_result(const scan_result&lt;OtherIt, OtherArgs...&gt;& other);

    constexpr scan_result(scan_result&&) = default;
    template&lt;class OtherIt, class... OtherArgs&gt;
      constexpr explicit(<i>see below</i>) scan_result(scan_result&lt;OtherIt, OtherArgs...&gt;&& other);

    constexpr scan_result& operator=(const scan_result&) = default;
    template&lt;class OtherIt, class... OtherArgs&gt;
      constexpr scan_result& operator=(const scan_result&lt;OtherIt, OtherArgs...&gt;& other);

    constexpr scan_result& operator=(scan_result&&) = default;
    template&lt;class OtherIt, class... OtherArgs&gt;
      constexpr scan_result& operator=(scan_result&lt;OtherIt, OtherArgs...&gt;&& other);

    constexpr iterator begin() const;

    template&lt;class Self&gt;
      constexpr auto&& values(this Self&&);

    template&lt;class Self&gt;
      requires sizeof...(Args) == 1
      constexpr auto&& value(this Self&&);

  private:
    iterator <i>begin_</i>;        // exposition only
    tuple&lt;Args...&gt; <i>values_</i>; // exposition only
  };
}
</pre>

Class template `basic_scan_context` synopsis {#spec-scan-context-synopsis}
--------------------------------------------

<pre highlight=cpp>
namespace std {
  template&lt;class Range, class CharT&gt;
  class basic_scan_context {
  public:
    using char_type = CharT;
    using range_type = Range;
    using iterator = ranges::iterator_t&lt;range_type&gt;;
    using sentinel = ranges::sentinel_t&lt;range_type&gt;;
    template&lt;class T&gt; using scanner_type = scanner&lt;T, char_type&gt;;

    constexpr basic_scan_arg&lt;basic_scan_context&gt; arg(size_t id) const noexcept;
    std::locale locale();

    constexpr iterator current() const;
    constexpr range_type range() const;
    constexpr void advance_to(iterator it);

  private:
    iterator <i>current_</i>;                         // exposition only
    sentinel <i>end_</i>;                             // exposition only
    std::locale <i>locale_</i>;                       // exposition only
    basic_scan_args&lt;basic_scan_context&gt; <i>args_</i>; // exposition only
  };
}
</pre>

Class template `basic_scan_args` synopsis {#spec-scan-args-synopsis}
-----------------------------------------

<pre highlight=cpp>
namespace std {
  template&lt;class Context&gt;
  class basic_scan_args {
    size_t <i>size_</i>;                   // exposition only
    basic_scan_arg&lt;Context&gt;* <i>data_</i>; // exposition only

  public:
    basic_scan_args() noexcept;

    template&lt;class... Args&gt;
      basic_scan_args(<i>scan-arg-store</i>&lt;Context, Args...&gt;& store) noexcept;

    basic_scan_arg&lt;Context&gt; get(size_t i) noexcept;
  };

  template&lt;class Context, class... Args&gt;
    basic_scan_args(<i>scan-arg-store</i>&lt;Context, Args...&gt;) -> basic_scan_args&lt;Context&gt;;
}
</pre>

Concept `scannable` {#spec-scannable}
-------------------------

<pre highlight=cpp>
namespace std {
  template&lt;class T, class Context,
           class Scanner = typename Context::template scanner_type&lt;remove_const_t&lt;T&gt;&gt;&gt;
    concept <i>scannable-with</i> =            // exposition only
      semiregular&lt;Scanner&gt; &&
      requires(Scanner& s, const Scanner& cs, T& t, Context& ctx,
               basic_format_parse_context&lt;typename Context::char_type&gt;& pctx)
      {
        { s.parse(pctx) } -> same_as&lt;expected&lt;typename decltype(pctx)::iterator, scan_error&gt;&gt;;
        { cs.scan(t, ctx) } -> same_as&lt;expected&lt;typename Context::iterator, scan_error&gt;&gt;;
      };

  template&lt;class T, class CharT&gt;
    concept scannable =
      <i>scannable-with</i>&lt;remove_reference_t&lt;T&gt;, basic_scan_context&lt;<i>unspecified</i>&gt;&gt;;
}
</pre>

Class template `basic_scan_arg` synopsis {#spec-scan-arg-synopsis}
----------------------------------------

<pre highlight=cpp>
namespace std {
  template&lt;class Context&gt;
  class basic_scan_arg {
  public:
    class handle;

  private:
    using char_type = typename Context::char_type;            // exposition only

    variant&lt;
      monostate,
      signed char*, short*, int*, long*, long long*,
      unsigned char*, unsigned short*, unsigned int*, unsigned long*, unsigned long long*,
      bool*, char_type*, void**,
      float*, double*, long double*,
      basic_string&lt;char_type&gt;*, basic_string_view&lt;char_type&gt;*,
      handle&gt; value;                                          // exposition only

    template&lt;class T&gt; explicit basic_scan_arg(T& v) noexcept; // exposition only

  public:
    basic_scan_arg() noexcept;

    explicit operator bool() const noexcept;
  };
}
</pre>

Exposition-only class template <code><i>scan-arg-store</i></code> synopsis {#spec-scan-arg-store}
--------------------------------------------------------------------------

<pre highlight=cpp>
namespace std {
  template&lt;class Context, class... Args&gt;
  class <i>scan-arg-store</i> {                                  // exposition only
    tuple&lt;Args...&gt; <i>args</i>;                                  // exposition only
    array&lt;basic_scan_arg&lt;Context&gt;, sizeof...(Args)&gt; <i>data</i>; // exposition only
  };
}
</pre>

<pre class=biblio>
{
  "P0645": {
    "title": "Text Formatting",
    "authors": ["Victor Zverovich"],
    "href": "https://wg21.link/p0645"
  },
  "CODESEARCH": {
    "title": "Code search engine website",
    "authors": ["Andrew Tomazos"],
    "href": "https://codesearch.isocpp.org"
  },
  "P1361": {
    "title": "Integration of chrono with text formatting",
    "authors": ["Victor Zverovich", "Daniela Engert", "Howard E. Hinnant"],
    "href": "https://wg21.link/p1361"
  },
  "PARSE": {
    "title": "Python `parse` package",
    "href": "https://pypi.org/project/parse/"
  },
  "ATTR": {
    "title": "Common Function Attributes",
    "href": "https://gcc.gnu.org/onlinedocs/gcc-8.2.0/gcc/Common-Function-Attributes.html"
  },
  "P1433": {
    "title": "Compile Time Regular Expressions",
    "authors": ["Hana Dusíková"],
    "href": "https://wg21.link/p1433"
  },
  "SCNLIB": {
    "title": "scnlib: scanf for modern C++",
    "authors": ["Elias Kosunen"],
    "href": "https://github.com/eliaskosunen/scnlib"
  },
  "FMT": {
    "title": "The fmt library",
    "authors": ["Victor Zverovich et al"],
    "href": "https://github.com/fmtlib/fmt"
  },
  "N4412": {
    "title": "N4412: Shortcomings of iostreams",
    "authors": ["Jens Maurer"],
    "href": "http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4412.html"
  },
  "P0355": {
    "title": "Extending <chrono> to Calendars and Time Zones",
    "authors": ["Howard E. Hinnant", "Tomasz Kamiński"],
    "href": "https://wg21.link/p0355"
  },
  "P2286": {
    "title": "Formatting Ranges",
    "authors": ["Barry Revzin"],
    "href": "https://wg21.link/p2286"
  },
  "P2561": {
    "title": "A control flow operator",
    "authors": ["Barry Revzin"],
    "href": "https://wg21.link/p2561"
  }
}
</pre>
