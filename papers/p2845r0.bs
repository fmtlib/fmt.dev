<pre class='metadata'>
Title: Formatting of std::filesystem::path
Shortname: P2845
Revision: 0
Audience: SG16
Status: D
Group: WG21
URL:
Editor: Victor Zverovich, victor.zverovich@gmail.com
No abstract: true
Date: 2023-04-14
Markup Shorthands: markdown yes
</pre>

<style type="text/css">
  td {
    vertical-align: middle;
  }
	ins { text-decoration: none; }
  ins code { background: #cfc !important; }

  .poll th, .poll td {
		text-align: right;
    width: 20%;
	}
</style>

<p style="text-align: right">
"The Tao is constantly moving, the path is always changing."
― Lao Tzu
</p>

Introduction {#intro}
============

[[P1636]] "Formatters for library types" proposed adding a number of
`std::formatter` specializations, including the one for `std::filesystem::path`.
However, SG16 recommended removing it because of quoting and localization
concerns. The current paper addresses these concerns and proposes adding an
improved `std::formatter` specialization for `path`.

Proposal
========

[[P1636]] proposed defining a `formatter` specialization for `path` in terms of
`ostream` insertion operator which, in turn, formats the native representation
wrapped in `quoted`. For example:

```c++
std::cout << std::format("{}, std::filesystem:::path("/usr/bin"));
```
would print `"/usr/bin"` with quotes being part of the output.

Unfortunately this has a number of problems, some of them raised in the LWG
discussion of the paper.

First, `std::quoted` only escapes the delimiter (`"`) and the escape character
itself (<code>\</code>). As a result the output may not be usable if the path contains
control characters such as newlines. For example:

```c++
std::cout << std::format("{}, std::filesystem:::path("multi\nline"));
```
would print
```text
"multi
line"
```
which is not a valid string in C++ and most other languages, most importantly,
including shell languages. This makes the output pretty much unusable and
interferes with formatting of ranges of paths.

Another problem is encoding. The representation return by the `native` member
function gives `basic_string<value_type>` where

> `value_type` is a `typedef` for the operating system dependent encoded
> character type used to represent pathnames.

`value_type` is normally `char` on POSIX and `wchar_t` on Windows.

When `value_type` doesn't match the character (code unit) type of a formatting
function, encoding conversion would be performed per [[fs.path.type.cvt](
http://eel.is/c++draft/fs.path.type.cvt)].

If the character type is `wchar_t` the method of conversion is unspecified.
For example, in libstdc++ even a basic case like

```c++
std::wcout.imbue(std::locale::classic()); // Mimick P1636.
std::wcout << std::filesystem::path("паляниця");
```

throws an exception:

```text
terminate called after throwing an instance of 'std::filesystem::__cxx11::filesystem_error'
  what():  filesystem error: Cannot convert character sequence: Invalid or incomplete multibyte or wide character
```

TODO: wchar_t -> char

Implementation
==============

TODO

<pre class=biblio>
{
  "P1636": {
    "title": "Formatters for library types",
    "authors": "Lars Gullik Bjønnes",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1636r2.pdf"
  }
}
</pre>
