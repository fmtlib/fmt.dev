<pre class='metadata'>
Title: Fixing locale handling in chrono formatters
Shortname: D2372
Revision: 0
<!-- !Draft Revision: 0 -->
Audience: LEWG
Status: D
Group: WG21
URL:
Editor: Victor Zverovich, victor.zverovich@gmail.com
Editor: Corentin Jabot, corentin.jabot@gmail.com
No abstract: true
Date: 2021-05-01
Markup Shorthands: markdown yes
</pre>

<style type="text/css">
  td {
    vertical-align: middle;
  }
	ins { text-decoration: none; }
  ins code { background: #cfc !important; }

  .poll th, .poll td {
		text-align: right;
    width: 20%;
	}
</style>

<p style="text-align: right">
"Mistakes have been made, as all can see and I admit it." <br>
― Ulysses S. Grant
</p>

The problem {#prob}
===========

In C++20 "Extending `<chrono>` to Calendars and Time Zones" ([[P0355]]) and
"Text Formatting" ([[P0645]]) proposals were integrated ([[P1361]]).
Unfortunately during this integration a design issue was missed: `std::format`
is locale-independent by default and provides control over locale via format
specifiers but the new formatter specializations for chrono types are localized
by default and don't provide such control.

For example:

```c++
  std::locale::global(std::locale("ru_RU"));

  std::string s1 = std::format("{}", 4.2);         // s1 == "4.2" (not localized)
  std::string s2 = std::format("{:L}", 4.2);       // s2 == "4,2" (localized)

  using sec = std::chrono::duration<double>;
  std::string s3 = std::format("{:%S}", sec(4.2)); // s3 == "04,200" (localized)
```

In addition to being inconsistent with the design of `std::format`, there is no
way to avoid locale other than doing formatting of date and time components
manually.

Confusingly, some chrono format specifiers such as `%S` may give an impression
that they are locale-independent by having a locale's alternative representation
like `%OS` while in fact they are not.

The implementation of [[P1361]] in [[FMT]] actually did the right thing and
made most chrono specifiers locale-independent by default, for example:

```
  using sec = std::chrono::duration<double>;
  std::string s = fmt::format("{:%S}", sec(4.2));  // s == "04.200" (not localized)
```

This implementation has been available and actively used in this form for 2+
years. The bug in the specification of chrono formatters in the standard and
the mismatch with the actual implementation have only been discovered recently
and reported in [[LWG3547]].

The solution
============

We propose fixing this issue by making chrono formatters locale-independent by default
and providing the `L` specifier to opt into localized formatting in the same way
as it is done for all other standard formatters
([format.string.std](https://eel.is/c++draft/format.string.std)).

<table>
<tr>
  <td>Before
  <td>After
</tr>
<tr>
  <td>
```
auto s = std::format("{:%S}", sec(4.2));
// s == "04,200"
```
  <td>
```
auto s = std::format("{:%S}", sec(4.2));
// s == "04.200"
```
</tr>
<tr>
  <td>
```
auto s = std::format("{:L%S}", sec(4.2));
// throws format_error
```
  <td>
```
auto s = std::format("{:L%S}", sec(4.2));
// s == "04,200"
```
</tr>
</table>

Locale alternative forms
========================

Some specifiers (`%d %H %I %m %M %S %u %w %y %z`) produce digits which are
not localized (aka they use the arabic numerals `0123456789`) although as we
demonstrated earlier `%S` is still using a localized decimal separator.
They have an equivalent form (`%Od %OH %OI %Om %OM %OS %Ou %Ow %Oy %Oz`)
where the numerals can be localized. for example Japanese numerals
`〇 一 二 三 四 五 ...` can be used as the "alternative representation" by a
`ja_JP` locale,

But because the `L` option applies to all specifiers, we do not propose to
modify the specifiers.

For example, `"{:L%p%I}"` and `"{:L%p%OI}"` should be valid specifiers producing
`午後1` `午後一` and respectiveely.

Appropriate use of numeral systems for localized numbers and dates
requires more work, this paper focuses on a consistent default behavior.

The "C" locale
==============

The "C" locale is used in the wording as a way to express locale-independent
behavior. The C standard specifies the "C" locale behavior for `strftime` as
follows

<blockquote>
In the "C" locale, the E and O modifiers are ignored
and the replacement strings for the following specifiers are:

<pre>
%a the first three characters of %A.
%A one of ''Sunday'', ''Monday'', ... , ''Saturday''.
%b the first three characters of %B.
%B one of ''January'', ''February'', ... , ''December''.
%c equivalent to ''%a %b %e %T %Y''.
%p one of ''AM'' or ''PM''.
%r equivalent to ''%I:%M:%S %p''.
%x equivalent to ''%m/%d/%y''.
%X equivalent to %T.
%Z implementation-defined.
</pre>
</blockquote>

This makes it possible, as long as the `L` option is not specified, to format
dates in environment without locale support (embedded platforms, `constexpr` if
someone proposes it, etc).

SG16 polls {#polls}
==========

Poll: LWG3547 raises a valid design defect in [time.format] in C++20.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>7
  <td>2
  <td>2
  <td>0
  <td>0
</tr>
</table>

Consensus: Strong consensus that this is a design defect.

Poll: The proposed LWG3547 resolution as written should be applied to C++23.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>0
  <td>4
  <td>2
  <td>4
  <td>1
</tr>
</table>

Consensus: No consensus for the resolution

SA motivation: Migrating things embedded in a string literal is very
difficult.  There are options to deal with this in an additive way.
Needless break in backwards with compatibility.

SG16 recognized that this is a design defect but was concerned about this
being a breaking change. However, the following facts were not known at the time
of the discussion:

* The implementation of [[P1361]] in [[FMT]] is locale-independent. This was the
    only implementation available for 2+ years and was cited as the only source
    of implementation experience in the paper.
* Both `%S` and `%OS` depend on locale and there is no locale-independent
    equivalent.
* The chrono formatting in the Microsoft's implementation has only been merged
    into the main branch on 22 April and has bugs that will require breaking
    changes.

Implementation experience {#impl}
=========================

The `L` specifier has been implemented for durations in the fmt library ([[FMT]]).
Additionally, some format specifiers like `S` have never used a locale by default
so this was a novel behavior accidentally introduced in C++20:

```
std::locale::global(std::locale("ru_RU"));
using sec = std::chrono::duration<double>;
std::string s = fmt::format("{:%S}", sec(4.2)); // s == "04.200" (not localized)
```

This proposal has been implemented in the Microsoft standard library and the
change is under review.

Impact on existing code {#impact}
=======================

Changing the semantics of chrono formatters to be consistent with standard
format specifiers ([format.string.std](https://eel.is/c++draft/format.string.std))
is a breaking change. At the time of writing the Microsoft's implementation
recenly merged the chrono formatting into the main branch and is known to be
not fully conformant. For example:

```
  using sec = std::chrono::duration<double>;
  std::string s = std::format("{:%S}", sec(4.2)); // s == "04" (incorrect)
```

Wording {#wording}
=======

All wording is relative to the C++ working draft [[N4885]].

Update the value of the feature-testing macro `__cpp_lib_format` to the date of
adoption in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/n4885.pdf#page=500">[version.syn]</a>:

Change in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/n4885.pdf#page=1324">[time.format]</a>:

<pre>
<i>chrono-format-spec</i>:
  <i>fill-and-align<sub>opt</sub> width<sub>opt</sub> precision<sub>opt</sub> <ins>L<sub>opt</sub></ins> chrono-specs<sub>opt</sub></i>
</pre>

2 Each conversion specifier *conversion-spec* is replaced by appropriate
characters as described in Table [tab:time.format.spec]; the formats specified
in ISO 8601:2004 shall be used where so described. Some of the conversion
specifiers depend on <del>the locale that is passed to the formatting function if the
latter takes one, or the global locale otherwise.</del> <ins> a locale. If the *L* option is
used, that locale is the locale that is passed to the formatting function if the
latter takes one, or the global locale otherwise. If the *L* option is not used,
that locale is the "C" locale.</ins> If the formatted object does not contain the
information the conversion specifier refers to, an exception of type
`format_error` is thrown.

<pre class=biblio>
{
  "FMT": {
    "title": "The {fmt} library",
    "authors": ["Victor Zverovich"],
    "etAl": true,
    "href": "https://github.com/fmtlib/fmt"
  },
  "P0355": {
    "title": "Extending to Calendars and Time Zones.",
    "authors": ["Howard E. Hinnant", "Tomasz Kamiński"],
    "href": "https://wg21.link/p0355"
  },
  "P0645": {
    "title": "Text Formatting",
    "authors": ["Victor Zverovich"],
    "href": "https://wg21.link/p0645"
  },
  "P1361": {
    "title": "Integration of chrono with text formatting",
    "authors": ["Victor Zverovich", "Daniela Engert", "Howard E. Hinnant"],
    "href": "https://wg21.link/p1361"
  },
  "LWG3547": {
    "title": "Time formatters should not be locale sensitive by default",
    "authors": ["Corentin Jabot"],
    "href": "https://cplusplus.github.io/LWG/issue3547"
  },
  "N4885": {
    "title": "Working Draft, Standard for Programming Language C++",
    "authors": ["Thomas Köppe"],
    "etAl": true,
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/n4885.pdf"
  }
}
</pre>
