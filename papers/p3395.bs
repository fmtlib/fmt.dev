<pre class='metadata'>
Title: Formatting of std::error_code
Shortname: P3395
Revision: 0
Audience: SG16
Status: P
Group: WG21
URL:
Editor: Victor Zverovich, victor.zverovich@gmail.com
No abstract: true
Date: 2024-12-21
Markup Shorthands: markdown yes
</pre>

<style type="text/css">
  td {
    vertical-align: middle;
  }
  ins { text-decoration: none; }
  ins code { background: #cfc !important; }

  .poll th, .poll td {
    text-align: right;
    width: 20%;
  }
</style>

Introduction {#intro}
============

This paper proposes making `std::error_code` formattable using the formatting
facility introduced in C++20 (`std::format`).

Motivation {#motivation}
==========

<!-- TODO: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2930r0.html#error_code -->

`error_code` has a rudimentary `ostream` inserter. For example:

```
std::error_code ec;
auto size = std::filesystem::file_size("nonexistent", ec);
std::cout << ec;
```

This works and prints `generic:2`.

However, the following code doesn't compile:

```
std::print("{}\n", ec);
```

Unfortunately, the existing inserter has several issues, such as I/O
manipulators applying only to the category name rather than the entire error
code, resulting in confusing output:

```
std::cout << std::left << std::setw(12) << ec;
```

This prints:

```text
generic     :2
```

Additionally, it doesn’t allow formatting the error message and introduces
potential encoding issues, as the encoding of the category name is unspecified.

Proposal {#proposal}
========

This paper proposes adding a `formatter` specialization for `std::error_code`
to address the problems discussed in the previous section.

The default format will produce the same output as the `ostream` inserter:

```
std::print("{}\n", ec);
```

Output:

```text
generic:2
```

It will correctly handle width and alignment:

```
std::print("[{:>12}]\n", ec);
```

Output:

```text
[   generic:2]
```

Additionally, it will allow formatting the error message:

```
std::print("{:s}\n", ec);
```

Output:

```text
No such file or directory
```

(The actual message depends on the platform.)

The main challenge lies in the standard's lack of specification for the
encodings of strings returned by `error_category::name` and
`error_code::message` / `error_category::message` ([syserr.errcat.virtuals](
https://eel.is/c++draft/syserr.errcat.virtuals)):

```
virtual const char* name() const noexcept = 0;
```

*Returns*: A string naming the error category.

```
virtual string message(int ev) const = 0;
```

*Returns*: A string that describes the error condition denoted by `ev`.

In practice, implementations typically define category names as string literals,
meaning they are in the ordinary literal encoding. 

<!-- https://github.com/llvm/llvm-project/blob/8f31ee996ae21ee77db29abb02a3aef4750e6d35/libcxx/src/system_error.cpp#L161 -->
<!-- https://github.com/gcc-mirror/gcc/blob/20486ec75734f3e641a3ade4297f6ba64881bca8/libstdc%2B%2B-v3/src/c%2B%2B11/system_error.cc#L589 -->
<!-- https://github.com/gcc-mirror/gcc/blob/20486ec75734f3e641a3ade4297f6ba64881bca8/libstdc%2B%2B-v3/src/c%2B%2B11/system_error.cc#L589 -->

However, there is significant divergence in message encodings. libc++ and
libstdc++ use `strerror[_r]` for the generic category which is in the C
(not "C") locale encoding but disagree on the encoding for the system category:
libstdc++ uses the Active Code Page (ACP) while libc++ again uses `strerror`
/ C locale on Windows. Microsoft STL uses a table of string literals in the
ordinary literal encoding for the generic category and ACP for the system
category.

The following table summarizes the differences:

<table>
<tr>
  <td>
  <td>libstdc++
  <td>libc++
  <td>Microsoft STL
</tr>
<tr>
  <td>POSIX
  <td>`strerror`
  <td>`strerror`
  <td>N/A
</tr>
<tr>
  <td>Windows
  <td>`strerror` / ACP
  <td>`strerror`
  <td>ordinary literals / ACP
</tr>
</table>

Obviously none of this is usable in a portable way through the generic
`error_category` API because encodings can be and often are different.

<!--What is worse, it is impossible to reliably get the information about the
message encoding because both the C locale and ACP can be changed at runtime,
possibly from another thread.

```c++
#include <locale.h>
#include <string.h>
#include <iostream>
#include <thread>

int main() {
  // Initial locale is "C".
  std::cout << setlocale(LC_ALL, nullptr) << std::endl;

  std::thread t([]() {
    setlocale(LC_ALL, "uk_UA.koi8-u");
  });

  t.join();
  std::cout << strerror(2) << std::endl;

  // ./a.out | iconv -f KOI8-U -t UTF-8
  // C
  // Немає такого файла або каталогу
}
```
-->

To address this, the proposal suggests using the C locale encoding (execution
character set), which is already employed in most cases and aligns with
underlying system APIs. Microsoft STL's implementation has a number of bugs in
`std::system_category::message` ([[MSSTL-3254]], [[MSSTL-4711]]) and will
likely need to change anyway. This also resolves [[LWG4156]].

An alternative approach could involve communicating the encoding from
`error_category`. However, this introduces ABI challenges and complicates usage
compared to adopting a single encoding.

<!-- ABI: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1196r0.html -->

Wording {#wording}
=======

Add to "Header &lt;system_error> synopsis" [[system.error.syn](
https://eel.is/c++draft/system.error.syn)]:

```
// [system.error.fmt], formatter
template<class charT> struct formatter<error_code, charT>;
```

Add a new section "Formatting" [system.error.fmt] under "Class `error_code`"
[[syserr.errcode](https://eel.is/c++draft/syserr.errcode)]:

<!-- TODO: debug format -->

<pre>
template&lt;class charT> struct formatter&lt;error_code, charT> {
  constexpr typename basic_format_parse_context&lt;charT>::iterator
    parse(basic_format_parse_context&lt;charT>& ctx);

  template&lt;class FormatContext>
    typename FormatContext::iterator
      format(const error_code& ec, FormatContext& ctx) const;
};
</pre>


<!--
```
constexpr void set_debug_format();
```

*Effects*: Modifies the state of the `formatter` to be as if the
*path-format-spec* parsed by the last call to `parse` contained the `?` option.
-->

```
constexpr typename basic_format_parse_context<charT>::iterator
  parse(basic_format_parse_context<charT>& ctx);
```

*Effects*: Parses the format specifier as a *error-code-format-spec* and stores the
parsed specifiers in `*this`.

<i>error-code-format-spec</i>:<br>
&nbsp;&nbsp;<i>fill-and-align<sub>opt</sub></i> <i>width<sub>opt</sub></i> <code>s</code><i><sub>opt</sub></i>

where the productions <i>fill-and-align</i> and <i>width</i> are described in
[[format.string](http://eel.is/c++draft/format#string)].

<!-- If the `?` option is
used then the path is formatted as an escaped string ([[format.string.escaped](
http://eel.is/c++draft/format.string.escaped)]). -->

*Returns*: An iterator past the end of the *error-code-format-spec*.

<pre>
  template&lt;class FormatContext>
    typename FormatContext::iterator
      format(const error_code& ec, FormatContext& ctx) const;
</pre>

*Effects*: Let `s` be `ec.message()` transcoded into the ordinary literal
encoding, with maximal subparts of ill-formed subsequences substituted with
U+FFFD REPLACEMENT CHARACTER per the Unicode Standard, Chapter 3.9 U+FFFD
Substitution in Conversion, if the `s` option is used, otherwise
`format("{}:{}", ec.category().name(), ec.value())`.
Writes `s` into `ctx.out()`, adjusted according to the *error-code-format-spec*.

*Returns*: An iterator past the end of the output range.

Modify [[syserr.errcat.virtuals](https://eel.is/c++draft/syserr.errcat.virtuals)]:

...

```
virtual string message(int ev) const = 0;
```

*Returns*: A string <ins>of multibyte characters in the executon character
set</ins> that describes the error condition denoted by `ev`.

Implementation {#impl}
==============

The proposed `formatter` for `std::error_code` has been implemented in the
open-source {fmt} library ([[FMT]]).

<pre class=biblio>
{
  "FMT": {
    "title": "The {fmt} library",
    "authors": ["Victor Zverovich"],
    "etAl": true,
    "href": "https://github.com/fmtlib/fmt"
  },
  "LWG4156": {
    "title": "`error_category` messages have unspecified encoding",
    "authors": ["Victor Zverovich"],
    "href": "https://cplusplus.github.io/LWG/issue4156"
  },
  "MSSTL-3254": {
    "title": "Visual Studio 2022 std::system_category returns \"unknown error\" if system locale is not en-US",
    "href": "https://github.com/microsoft/STL/issues/3254"
  },
  "MSSTL-4711": {
    "title": "Should `std::error_code::message` respect the locale set by the user?",
    "authors": ["Sung Po-Han"],
    "href": "https://github.com/microsoft/STL/issues/4711"
  }
}
</pre>
