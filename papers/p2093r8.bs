<pre class='metadata'>
Title: Formatted output
Shortname: P2093
Revision: 8
Audience: LEWG
Status: D
Group: WG21
URL:
Editor: Victor Zverovich, victor.zverovich@gmail.com
No abstract: true
Date: 2021-08-15
Markup Shorthands: markdown yes
</pre>

<style type="text/css">
  td {
    vertical-align: middle;
  }
	ins { text-decoration: none; }
  ins code { background: #cfc !important; }
  .parnum {
    display: block;
    height: 0;
    position: relative;
    left: -24px;
    font-size: small;
  }
</style>

<p style="text-align: right">
"╨ƒ╤Ç╨╕╨▓╨╡╤é, ╬║╧î╧â╬╝╬┐╧é!" <br>
― anonymous user
</p>

Introduction {#intro}
============

A new I/O-agnostic text formatting library was introduced in C++20 ([[FORMAT]]).
This paper proposes integrating it with standard I/O facilities via a simple and
intuitive API achieving the following goals:

* Usability
* Unicode support
* Good performance
* Small binary footprint

Revision history {#hist}
================

Changes since R7:

* Added a reference to LLVM's `raw_ostream` that implements similar mojibake
    prevention mechanism to [[#impl]]

Changes since R6:

* Added new SG16 poll results.

* Rebased the wording onto the latest draft, most importantly adding
    compile-time checks introduced by [[P2216]].

* Added "If `out` contains invalid code units, the behavior is undefined and
    implementations are encouraged to diagnose it."
    to the definition of `vprint_unicode` per SG16 feedback.

* Replaced "invalid code points are substituted with U+FFFD � REPLACEMENT
    CHARACTER" with " implementations should substitute invalid code units with
    U+FFFD � REPLACEMENT CHARACTER per The Unicode® Standard Version 13.0 – Core
    Specification, Chapter 3.9" in [[#wording]] per SG16 feedback.

* Added "The Unicode® Standard Version 13.0 – Core Specification" to
    Normative references in [[#wording]].

* Clarified the behavior when mixing encodings in [[#unicode]].

Changes since R5:

* Added new LEWG poll results.
* Added new SG16 poll results.
* Replaced `<io>` with `<print>` per LEWG feedback.
* Clarified the choice of U+FFFD � REPLACEMENT CHARACTER for transcoding errors
    in [[#unicode]].
* Clarified the choice of literal encoding in [[#unicode]].
* Clarified that ANSI escape codes for specifying coding systems are not
    considered a native system API that supports Unicode in [[#unicode]].
* Added a reference to Rust's standard output facility that implements the same
    mojibake prevention mechanism to [[#impl]]

Changes since R4:

* Added SG16 Unicode poll results.
* Added a list of candidate headers formatted output functions can be added to.
* Moved the non-`ostream` overloads of formatted output functions to a separate
    header for cleaner separation of formatting and I/O facilities.

Changes since R3:

* Replaced `_isatty(_fileno(stream))` with
    `GetConsoleMode(_get_osfhandle(_fileno(stream)), ...)` in a note in
    [format.functions] because the former may return 1 for streams not referring
    to a terminal.

Changes since R2:

* Added better compatibility with other formatted I/O facilities as another
    advantage of using `stdout` in [[#api]] per SG16 feedback.

* Clarified that [[P1885]] can be used for literal encoding detection per SG16
    feedback.

* Added comparison of Unicode handling in various languages in [[#lst]] and a
    summary in [[#unicode]] per SG16 request.

* Removed incorrect "exposition-only" in [[#unicode]].

* Replaced "both source and literal encodings are UTF-8, which is enabled by the
    <code highlight="text">/utf-8</code> compiler flag" with "the literal
    (execution) encoding is UTF-8, which is enabled by the
    <code highlight="text">/execution-charset:utf-8</code> compiler flag" since
    the source encoding is irrelevant there.

* Rephrased *Effects* of ``vprint_unicode`` for clarity.

Changes since R1:

* Added missing `println` overloads that take `FILE*` and `ostream&`.
* Moved the print functions that take `ostream&` to `<ostream>` since `<format>`
    shouldn't depend on `<ostream>`.
* Clarified why it is useful to provide `vprint*` functions in [[#binary]].
* Rebased the wording onto the latest working draft, N4861, in particular
    updating the *Throws* clauses to match existing wording.
* Replaced `std::system_error` with `system_error` in the wording.
* Added paragraph numbers to the wording.

Changes since R0:

* Clarified that adding `wchar_t` overloads will be addressed in a separate
    paper per the UK C++ panel feedback.

SG16 polls (R6) {#sg16-polls6}
===============

**Poll**: When `<print>` facilities must transcode their formatting results for
display on a device, and during that process invalidly-encoded text is
encountered, `print()` should replace the erroneously-encoded code units with
`U+FFFD REPLACEMENT CHARACTER`.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>3
  <td>3
  <td>1
  <td>2
  <td>0
</tr>
</table>

Outcome: Consensus for the position

**Poll**: When `<print>` facilities need not transcode their formatting results
for display on a device, and during that process invalidly-encoded text is
encountered, `print()` should nevertheless replace the erroneously-encoded code
units with `U+FFFD REPLACEMENT CHARACTER`.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>1
  <td>0
  <td>2
  <td>2
  <td>3
</tr>
</table>

Outcome: Consensus against the direction.

**Poll**: `<format>` and `<print>` facilities should have consistent behavior
with respect to encoding expectations for the format string.

No objection to unanimous consent.

**Poll**: formatters should not be sensitive to whether they are being used with a
`<format>` or `<print>` facility.

No objection to unanimous consent.

**Poll**: Regardless of format string encoding assumptions, `<format>` facilities
may be used to format binary data.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>5
  <td>1
  <td>1
  <td>0
  <td>0
</tr>
</table>

Consensus: Strong consensus in favor.

**Poll**: Regardless of format string encoding assumptions, `<print>` facilities may
be used to format binary data.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>2
  <td>1
  <td>3
  <td>1
  <td>0
</tr>
</table>

Consensus: Weak consensus in favor.

**Poll**: `<print>` facilities exhibit undefined behavior when an encoding
expectation is present and a format string or formatter output does not match
those expectations.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>2
  <td>4
  <td>0
  <td>0
  <td>1
</tr>
</table>

Consensus: Strong consensus in favor.

**Poll**: `<print>` facilities exhibit undefined behavior when an encoding
expectation is present and a format string or formatter output does not match
those expectations and output is directed to a device that has encoding
expectations.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>6
  <td>0
  <td>1
  <td>0
  <td>0
</tr>
</table>

Consensus: Stronger consensus in favor relative to previous poll.

**Poll**: `<print>` facility implementors are encouraged to provide a run-time
means for diagnosing format strings and formatter output that is not well-formed
according to the expected encoding.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>4
  <td>0
  <td>2
  <td>1
  <td>0
</tr>
</table>

Consensus: Consensus in favor.

**Poll**: `<format>` and `<print>` facilities should have consistent behavior
with respect to encoding expectations for the output of formatters.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>0
  <td>1
  <td>1
  <td>5
  <td>1
</tr>
</table>

Consensus: Strong consensus against.

**Poll**: `<print>` facility implementors are encouraged to substitute `U+FFFD`
replacement characters following Unicode guidance when output is directed to a
device and transcoding is necessary.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>2
  <td>5
  <td>0
  <td>0
  <td>1
</tr>
</table>

Consensus: Consensus in favor.

**Poll**: `<print>` facilities must provide an explicit program-controlled error
handling mechanism for violations of encoding expectations.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>0
  <td>0
  <td>3
  <td>3
  <td>3
</tr>
</table>

**Poll**: Use of UTF-8 as the literal encoding is sufficient for `<print>`
facilities to establish encoding expectations.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>3
  <td>1
  <td>3
  <td>2
  <td>0
</tr>
</table>

Consensus: Very weak consensus.

LEWG polls (R5) {#lewg-polls5}
===============

<!-- https://wiki.edg.com/bin/view/Wg21telecons2021/P2093?twiki_redirect_cache=a3b691de29417a0240d9e2b83122b331 -->

Poll: Block P2093 until we have a proposal for a lower level facility that can
query tty/console and perform direct output to the console

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>2
  <td>1
  <td>5
  <td>5
  <td>6
</tr>
</table>

Outcome: Consensus Against

Poll: We want `std::print` et al. non `ostream` overloads to go to:

<table class="poll">
<tr>
  <th>Header
  <th>Approve
  <th>Disapprove
</th>
<tr>
  <td>`<ostream>`
  <td>3
  <td>7
</tr>
<tr>
  <td>`<io>`
  <td>6
  <td>5
</tr>
<tr>
  <td>`<print>`
  <td>10
  <td>3
</tr>
<tr>
  <td>`<format>`
  <td>12
  <td>1
</tr>
<tr>
  <td>`<utility>`
  <td>1
  <td>13
</tr>
</table>

Outcome: both `<print>` and `<format>` have consensus, author can choose one for the
  next revision.

SG16 polls (R3) {#sg16-polls3}
===============

Poll: Forward P2093R3 to LEWG.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>4
  <td>2
  <td>2
  <td>0
  <td>1
</tr>
</table>

Consensus? Yes

LEWG polls (R2) {#lewg-polls2}
===============

Poll: We want P2093R2 to revert moving the `print(ostream)` overloads to the
`<ostream>` header.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>0
  <td>0
  <td>6
  <td>6
  <td>1
</tr>
</table>

Outcome: Keep the paper as is

LEWG polls (R1) {#lewg-polls1}
===============

Poll: We prefer `std::cout` as the default output target.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>3
  <td>2
  <td>6
  <td>6
  <td>5
</tr>
</table>

Poll: Add a member function on `ostream` instead of a
`std::print(ostream&, ...)` free function overload.

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>0
  <td>2
  <td>5
  <td>17
  <td>3
</tr>
</table>

Consensus against.

Poll: Remove `std::println` from the paper?

<table class="poll">
<tr>
  <th>SF
  <th>F
  <th>N
  <th>A
  <th>SA
</th>
<tr>
  <td>1
  <td>10
  <td>7
  <td>4
  <td>4
</tr>
</table>

No consensus for change.

Poll: We are happy with the design with regards to UTF-8 output.

Unanimous consent.

Attendance: 35

Motivating examples {#motivation}
===================

Consider a common task of printing formatted text to `stdout`:

<table width="100%">
<tr>
  <th>C++20</th>
  <th>Proposed</th>
</tr>
<tr>
  <td>
    <pre lang="cpp">
    std::cout << std::format("Hello, {}!", name);
    </pre>
  </td>
  <td>
    <pre lang="cpp">
    std::print("Hello, {}!", name);
    </pre>
  </td>
</tr>
</table>

The proposed `std::print` function improves usability, avoids allocating a
temporary `std::string` object and calling `operator<<` which performs formatted
I/O on text that is already formatted. The number of function calls is reduced
to one which, together with `std::vformat`-like type erasure, results in much
smaller binary code (see [[#binary]]).

Existing alternatives in C++20:

<table width="100%">
<tr>
  <th>Code</th>
  <th>Comments</th>
</tr>
</tr>
  <td>
    <pre lang="cpp">
    std::cout << "Hello, " << name << "!";
    </pre>
  </td>
  <td>
    Requires even more formatted I/O function calls; message is interleaved
    with parameters; can result in interleaved output.
  </td>
</tr>
<tr>
  <td>
    <pre lang="cpp">
    std::printf("Hello, %s!", name);
    </pre>
  </td>
  <td>
    Only works if `name` is a null-terminated character string.
  </td>
<tr>
<tr>
  <td>
    <pre lang="cpp">
    auto msg = std::format("Hello, {}!", name);
    std::fputs(msg.c_str(), stdout);
    </pre>
  </td>
  <td>
    Constructs a temporary string; requires a call to `c_str()` and a separate
    I/O function call, although potentially cheaper than `operator<<`.
  </td>
<tr>
</table>

Another problem is formatting of Unicode text:
```
std::cout << "Привет, κόσμος!";
```
If the source and execution encoding is UTF-8 this will produce the expected
output on most GNU/Linux and macOS systems. Unfortunately on Windows it is
almost guaranteed to produce [mojibake](https://en.wikipedia.org/wiki/Mojibake)
despite the fact that the system is fully capable of printing Unicode, for
example
```
╨ƒ╤Ç╨╕╨▓╨╡╤é, ╬║╧î╧â╬╝╬┐╧é!
```
<!-- Active code page: 437 (chcp) -->
even when compiled with <code highlight="text">/utf-8</code> using Visual C++
([[MSVC-UTF8]]). This happens because the terminal assumes code page 437 in this
case independently of the execution encoding.
<!-- The user-specified encoding is ignored which is not ideal. -->

With the proposed paper
```
std::print("Привет, κόσμος!");
```
will print `"Привет, κόσμος!"` as expected allowing programmers to write Unicode
text portably using standard facilities. This will bring C++ on par with other
languages where such functionality has been available for a long time.
For comparison this just works in Python 3.8 on Windows with the same active
code page and console settings:
```
>>> print("Привет, κόσμος!")
Привет, κόσμος!
```

This problem is independent of formatting `char8_t` strings but the same
solution applies there. Adding `charN_t` and `wchar_t` overloads will be
explored in a separate paper in a more general context.

API and naming {#api}
==============

Many programming languages provide functions for printing text to standard
output, often combined with formatting:

<table width="100%">
<tr>
  <th style="text-align: left">Language</th>
  <th style="text-align: left">Function(s)</th>
</tr>
<tr>
  <td>C</td>
  <td>`printf` [[N2176]]</td>
</tr>
<tr>
  <td>C#/.NET</td>
  <td>`Console.Write` [[DOTNET-WRITE]]</td>
</tr>
<tr>
  <td>COBOL</td>
  <td>`DISPLAY` statement [[N0147]]</td>
</tr>
<tr>
  <td>Fortran</td>
  <td>`print` and `write` statements [[N2162]]</td>
</tr>
<tr>
  <td>Go</td>
  <td>`Printf` [[GO-FMT]]</td>
</tr>
<tr>
  <td>Java</td>
  <td>`PrintStream.format`, `PrintStream.print`, `PrintStream.printf`
      [[JAVA-PRINT]]</td>
</tr>
<tr>
  <td>JavaScript</td>
  <td>`console.log` [[WHATWG-CONSOLE]]</td>
</tr>
<tr>
  <td>Perl</td>
  <td>`printf` [[PERL-PRINTF]]</td>
</tr>
<tr>
  <td>PHP</td>
  <td>`printf` [[PHP-PRINTF]]</td>
</tr>
<tr>
  <td>Python</td>
  <td>`print` statement or function [[PY-FUNC]]</td>
</tr>
<tr>
  <td>R</td>
  <td>`print` [[R-PRINT]]</td>
</tr>
<tr>
  <td>Ruby</td>
  <td>`print` and `printf` [[RUBY-PRINT]]</td>
</tr>
<tr>
  <td>Rust</td>
  <td>`print!` [[RUST-PRINT]]</td>
</tr>
<tr>
  <td>Swift</td>
  <td>`print` [[SWIFT-PRINT]]</td>
</tr>
</table>

Variations of `print[f]` appear to be the most popular naming choice for this
functionality. It is either provided as a free function (most common) or a
member function (less common) together with a global object representing
standard output stream. Notable exceptions are COBOL, Fortran, and Python 2
which have dedicated language statements and Rust where `print!` is a
function-like macro.

We propose adding a free function called `print` with overloads for writing to
the standard output (the default) and an explicitly passed output stream object.
The default output stream can be either `stdout` or `std::cout`. We propose
using `stdout` for the following reasons:

* `stdout` is considerably faster on at least two major implementations
    (see [[#perf]]).

* Better compatibility with other formatted I/O facilities compared to
    `std::cout` and its associated `std::streambuf` that suffer from private
    buffering, localization and conversion services that must be synchronized at
    a lower level.

* `print` won't use any formatted output functionality of `ostream`.

Since `stdout` doesn't have an associated
locale we propose using the current global locale for locale-specific formatting
which is consistent with `format`. With `cout` or another explicitly passed
stream, the stream's locale will be used. In all cases the default formatting is
locale-independent.

Another option is to make `print` a member function of `basic_ostream`. This
would make usage somewhat more awkward:
```c++
std::cout.print("Hello, {}!", name);
```
A free function can also be overloaded to take `FILE*` to simplify migration
(possibly automated) of code from `printf` to the new facility.

There are multiple approaches to appending a trailing newline:

* Don't append a newline automatically: `printf` in C and other languages.
* Append a newline but don't format arguments: `puts` in C (inconsistent with
    `fputs`).
* Have two formatting functions/macros, one that appends newline and another
    that doesn't: `print`/`println` in Java, `print!`/`println!` in Rust,
    `Printf`/`Println` in Go, `Write`/`WriteLine` in C#/.NET.
* Let the user choose a terminating string defaulting to `"\n"` and do limited
    formatting: `print` in Python and Swift.

<!-- https://stackoverflow.com/questions/61853002/why-does-c-puts-appends-a-newline-while-fputs-doesnt -->

We propose not appending a newline automatically for consistency with `printf`
and iostreams:

```c++
std::print("Hello, {}!", name);    // doesn't print a newline
std::print("Hello, {}!\n", name);  // prints a newline
```

Additionally we can provide a function that appends a newline:

```c++
std::println("Hello, {}!", name);  // prints a newline
```

Although `println` doesn't provide much usability improvement compared to
`print` with explicit `'\n'`, it has been a frequently requested feature in the
fmt library ([[FMT]]).

<!-- https://twitter.com/vzverovich/status/1261986120683806721 --> 

Another question is which header non-`ostream` overloads of formatted output
functions should go to. Possible options:

* `<io>`
* `<print>`
* `<format>`
* `<ostream>`
* `<utility>`

Earlier versions of the paper proposed `<io>` analogous to `<cstdio>` so that
the future I/O facilities that don't depend on ostream could be added there.
This was changed to a more narrow-focused `<print>` but `<io>` can be added in
the future once a symmetric input facility becomes available. Using `<ostream>`
is undesirable because this header and its transitive dependencies are very big
(42 thousand lines preprocessed on libc++):

```
% echo '#include <ostream>' | clang++ -E -x c++ - | wc -l
   42491
```

It also pulls in a lot of unrelated symbols such as `ostream` insertion
operators, global `cout`, `cerr`, `clog` variables and their `wchar_t`
counterparts.

`ostream` overloads are added to the `<ostream>` header.

Unicode {#unicode}
=======

We can prevent mojibake in the Unicode example by detecting if the string
literal encoding is UTF-8 and dispatching to a different function that correctly
handles Unicode, for example:

<!-- Cannot use "µ" because MSVC uses the current user code page as the source
     encoding. -->
```
constexpr bool is_utf8() {
  const unsigned char micro[] = "\u00B5";
  return sizeof(micro) == 3 && micro[0] == 0xC2 && micro[1] == 0xB5;
}

template <typename... Args>
void print(string_view fmt, const Args&... args) {
  if (is_utf8())
    vprint_unicode(fmt, make_format_args(args...));
  else
    vprint_nonunicode(fmt, make_format_args(args...));
}
```
where the `vprint_unicode` function formats and prints text in UTF-8 using the
native system API that supports Unicode and `vprint_nonunicode` does the same
for other encodings. The latter ensures that interoperability with code using
legacy encodings is preserved even though `print` is a new API and it is not
strictly necessary. If calling the system API requires transcoding we propose
substituting invalid code units with U+FFFD � REPLACEMENT CHARACTER
which is consistent with the treatment of malformed UTF-8 in UTF-8-native
terminals. For example

```c++
#include <stdio.h>

int main() {
  puts("\xc3\x28"); // Invalid 2 Octet Sequence
}
```
prints `�(` in iTerm2 and `?(` in macOS Terminal. So whether transcoding is done
or not in the UTF-8 case, you will normally get similar observed behavior.

<!-- Check encoding term with Corentin. Probably literal encoding per
     https://twitter.com/vzverovich/status/1241752737831718912 -->
In Visual C++ `is_utf8` will return `true` if the literal (execution) encoding
is UTF-8, which is enabled by the <code highlight="text">/execution-charset:utf-8</code>
compiler flags or other means, and `false` otherwise. Literal encoding detection
can be implemented in a more elegant way using [[P1885]].

Note that ANSI escape codes for specifying coding systems ([[ISO2022]]) are not
considered a native system API that supports Unicode for the purposes of this
proposal.

<!-- https://en.wikipedia.org/wiki/ISO/IEC_2022#Interaction_with_other_coding_systems -->

We propose using the literal encoding for the following reasons:

1. Consistency with the design of `std::format` which is locale-independent by
     default ([[P0645]]) and disallows implicitly mixing encodings
     e.g. passing a narrow string into a wide `std::format` is ill-formed.
2. Consistency with the encoding used for width estimation ([[P1868]]).
     The standard wording doesn't mention the literal encoding explicitly but
     the fact that the format strings are either literals or other compile-time
     strings ([[P2216]]) makes it the only conformant option.
3. Safety: the result of `formatted_size` does not depend on the global locale
     by default and a buffer allocated with this size can be passed safely to
     `format_to` even if the locale has been changed in the meantime, possibly
     from another thread.
4. Implementation and usage experience.
5. In the vast majority of cases format strings are literals. For example,
     analyzing a sample of 100 `printf` calls from [[CODESEARCH]] showed that 98
     of them are string literals and 2 are string literals wrapped in the `_`
     gettext macro.
6. The active code page and the terminal encoding being unrelated on popular
     Windows localizations such as Russian where the former is CP1251 while the
     latter is CP866. Instead of assuming one encoding regardless of the string
     origin which would often result in mojibake, an explicit encoding
     indication can be done via the standard extension API, e.g.
     (exposition only)
     ```
print("Привет, {}!", locale_enc(string_in_locale_encoding));
     ```
     This is already possible to implement by providing appropriate
     `std::formatter` specializations.

This approach has been implemented in the fmt library ([[FMT]]), successfully
tested and used on a variety of platforms.

Users can sometimes restrict the set of used characters to the common subset
among multiple encodings (often ASCII) in which case encoding becomes mostly
irrelevant. Such "polyglot" strings are fully supported for legacy encodings 
and partially supported for UTF-8 by the current proposal even though mixing
encodings in such a way is a clearly bad practice from a general software
engineering point of view.

Here's an example output on Windows:

<img width="100%" src="data:image/png;base64,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AAECnSbgoUanXRH9IUCAAAECBAgQIECAAAECBBoS8FCjISYnESBAgAABAgQIECBAgAABAp0mMKWTOtRVOju6M39Db8RlRx6KuGRhijsmd3VSd/VlnAsU77c568+NEd2wtactI5t911NRz+o5P464dtbKiJtP7m5L/SohQIAAAQIECBAgQIDARBeQqTHR7wDjJ0CAAAECBAgQIECAAAEC41SgozI1xtowv1m/9eVPR1eu6H11VLs01u23Otjx3v9Wx688AQIECBAgQIAAAQIECIyugEyN0fXWGgECBAgQIECAAAECBAgQINAmgY7K1BgsvRDD2rjwohTzIM2lkSXEcSTwzIoPR2/n5j6bSyNLiAQIECBAgAABAgQIEGiLgEyNtjCqhAABAgQIECBAgAABAgQIEBhtga5TemYP5tVGLnj4jmj/4MoVES8ZGCz3Z1/ExxZ/JuKaPZWrQ0xauin2bz68NOK8KesibrvqtIj547UNV8XX4lwVuXzx/Kn9X47zZ696PFdREYurVzTb/1rtVjTypo16/XnTqQ19bXf7eU6L1ef/taL97gPrY7vWKjJFx+unHakonzeeu2tWfM2rg7S7/7mdZmPd/nf1RZXF1UeK5easvzbOe/qz34541KH6/V8sf/T8KH70o0b7R0/wjQABAgQIECBAgAABAgSGIyBTYzhqyhAgQIAAAQIECBAgQIAAAQJjLlCRqZHfNNd6I//knH+NDhff+Bff2BczA55+7xej3KbeD0bcteiKiMWMj9j5xkeu7xfTUsZHo5ka1097OaooZpQ0Wl/OdBhvq5/kft9/+LYYf9Gr3vFGffL1qRVzO6PlV8yUuLovZRLVygQq3r87J783hpIzlWrd/4cuuzvO237zoYjFjI9aHodmLotDmx54a8Qt562MuNncGrXI7CdAgAABAgQIECBAgEBTAjI1muJyMgECBAgQIECAAAECBAgQINApAhWrnxQzNHInu9Z+J74+uuDKiJ84a23EHYW5NYoZGjvKq5ac+sLeOH93V8rUiI0R+Hjurupzfvxhb5oT4a9zZkSr5xzpi5j7NwJdGZUqJw9cHu3MveCliBuv21Jut3LOk20Pb4z9Ox/4WMR5f/pJxGLGwOsXHf94ufKOCX+c+fHoyydP/2nEb9/z29S3QiZErft3557KodS6/0/9/pNx4g9vSff/me//Syq4p7uyAlsECBAgQIAAAQIECBAgMKoCMjVGlVtjBAgQIECAAAECBAgQIECAQLsEKjI1Wq20+5WUMVDMgDgy6dGoevVHUiyVKjMJWm13rMsPzZ3QmzJFZuRFY3LHRmj1i9+fPT1amDn49ogzHtwe8VO53WIcSBkrxUyDgXXz48yLS2kVm23PPhXbXyiXb/eqL8VuDXv7XWdE0ffs2xXx3rdUv50HJv06ju89eGbEOe+OUCoVMjXKewUCBAgQIECAAAECBAgQGCcCMjXGyYXSTQIECBAgQIAAAQIECBAgQKBSoPqr7cpzSkMZAeVX21t+eVI64+TCiRN0s2f3fTHyRR9NsSZDYa6Hmuc1eODoXCX7o0S9VWWOVls9UyZnbMxNi86UiquLPPO1VVFFcXWVo/WO8rffpMyTX52RMlbO+vPh6MCOgvOkgZSaMf30V+L4/pS4Mcqd1RwBAgQIECBAgAABAgQItFtApka7RdVHgAABAgQIECBAgAABAgQIjIpAQ5kaF39uQXTmfU/cFnFR4U34qPR0FBrZvv9gtHLaRZdFPOebD0UszhEyUl1ptv08V0nfz2+JLt1/3aUR16x6vC1dHCy9EPV8t/93EZdPO361zfa/WFtezWV5/41x6JLBn0VcO2tlxOJqLafsTqu4/Ohgbxy/9saUYrK599XYzh/nrU4+l+/7Vuxa8mI5xWhyPuP4MZe/snz/zy6s+nP80o4SIECAAAECBAgQIECAwEgJyNQYKVn1EiBAgAABAgQIECBAgAABAiMqUJGp8YEVafWMvhWVbU7tTxka7Z5LoThnw/XTjlQ0/Hrp9tju60u7R3oVjsF1X4mG7rswvflf++RnU8Plz05t/9kVn48ertmQ+t3XV+mYB1Hsfz3/XK77wPr4unhhX9o1uSsfqoij7ZczSR5ZcHf0Y3r/IxH7Fg5W9Kv7QDlDY2Fl5k1xFKN9/1d00gYBAgQIECBAgAABAgQINC0gU6NpMgUIECBAgAABAgQIECBAgACBThDoOqVn9uD88hv+OevPjT7dsLWnE/qmDwTGtcChy1IGyfNX74pxLClkiozrwek8AQIECBAgQIAAAQIEOkBApkYHXARdIECAAAECBAgQIECAAAECBJoXqJhTo/niShAgUBTIc5UsvuZDcah7z2MRR2sVnWJ/bBMgQIAAAQIECBAgQOBEFZCpcaJeWeMiQIAAAQIECBAgQIAAAQInuIBMjRP8AhveyAkcmrksKt/U+5mIMyoXXSlN7V8V+9u9atDIjUjNBAgQIECAAAECBAgQGF8CMjXG1/XSWwIECBAgQIAAAQIECBAgQKAs0NXT01N4v8yGAAECBAgQIECAAAECBAgQIND5AjI1Ov8a6SEBAgQIECBAgAABAgQIECBQRcBDjSoodhEgQIAAAQIECBAgQIAAAQKdL+ChRudfIz0kQIAAAQIECBAgQIAAAQIEqgh4qFEFxS4CBAgQIECAAAECBAgQIECg8wU81Oj8a6SHBAgQIECAAAECBAgQIECAQBUBDzWqoNhFgAABAgQIECBAgAABAgQIdL6Ahxqdf430kAABAgQIECBAgAABAgQIEKgi4KFGFRS7CBAgQIAAAQIECBAgQIAAgc4X8FCj86+RHhIgQIAAAQIECBAgQIAAAQJVBDzUqIJiFwECBAgQIECAAAECBAgQIND5Ah5qdP410kMCBAgQIECAAAECBAgQIECgioCHGlVQ7CJAgAABAgQIECBAgAABAgQ6X8BDjc6/RnpIgAABAgQIECBAgAABAgQIVBHwUKMKil0ECBAgQIAAAQIECBAgQIBA5wt4qNH510gPCRAgQIAAAQIECBAgQIAAgSoCHmpUQbGLAAECBAgQIECAAAECBAgQ6HwBDzU6/xrpIQECBAgQIECAAAECBAgQIFBFwEONKih2ESBAgAABAgQIECBAgAABAp0v4KFG518jPSRAgAABAgQIECBAgAABAgSqCHioUQXFLgIECBAgQIAAAQIECBAgQKDzBTzU6PxrpIcECBAgQIAAAQIECBAgQIBAFQEPNaqg2EWAAAECBAgQIECAAAECBAh0voCHGp1/jfSQAAECBAgQIECAAAECBAgQqCLgoUYVFLsIECBAgAABAgQIECBAgACBzhfwUKPzr5EeEiBAgAABAgQIECBAgAABAlUEPNSogmIXAQIECBAgQIAAAQIECBAg0PkCHmp0/jXSQwIECBAgQIAAAQIECBAgQKCKgIcaVVDsIkCAAAECBAgQIECAAAECBDpfwEONzr9GekiAAAECBAgQIECAAAECBAhUEfBQowqKXQQIECBAgAABAgQIECBAgEDnC3io0fnXSA8JECBAgAABAgQIECBAgACBKgIealRBsYsAAQIECBAgQIAAAQIECBDofAEP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" alt="" />

At the same time interoperability with legacy code is preserved when literal
encoding is not UTF-8. In particular, in case of EBCDIC, Shift JIS or a
non-Unicode Windows code page, `print` will perform no transcoding and the text
will be printed as is.

<!-- and rendered correctly if the stars align and literal,
execution and console encodings all match. -->

<!-- GCC implementation of P1885:
     https://github.com/cor3ntin/gcc/commit/830762e817867fc1406548c2d5e38a2f2aab5dd6 -->

<!--There is a preexisting problem with interoperability between programs that
produce UTF-8 output and programs that assume that inputs are in encoded
according to the Active Code Page (ACP) on Windows. Since UTF-8 is a widely used
file encoding, redirecting an input from a file can result in UTF-8 encoded
input that can be further piped between programs. This problem affects even
standard Microsoft commands. For example, `type test.cc` will give mojibake if
`test.cc` is UTF-8 encoded and have characters not representable in the ACP:

```
> type test
#include <iostream>

int main() {
  std::cout << "╨ƒ╤Ç╨╕╨▓╨╡╤é, ╬║╧î╧â╬╝╬┐╧é!";
}
```
-->

The following table summarizes the behavior of formatted output facilities in
different programming languages:

<table width="100%">
<tr>
  <th>
  <th colspan="2">Linux</th>
  <th colspan="2">macOS</th>
  <th colspan="2">Windows</th>
</tr>
<tr>
  <th style="text-align: left">Language</th>
  <th style="text-align: left">Terminal</th>
  <th style="text-align: left">Redirect</th>
  <th style="text-align: left">Terminal</th>
  <th style="text-align: left">Redirect</th>
  <th style="text-align: left">Terminal</th>
  <th style="text-align: left">Redirect</th>
</tr>
<tr>
  <td>C</td>
  <td>Correct</td>
  <td>UTF-8</td>
  <td>Correct</td>
  <td>UTF-8</td>
  <td>Wrong</td>
  <td>UTF-8</td>
</tr>
<tr>
  <td>Go</td>
  <td>Correct</td>
  <td>UTF-8</td>
  <td>Correct</td>
  <td>UTF-8</td>
  <td>Correct</td>
  <td>UTF-8</td>
</tr>
<tr>
  <td>Java</td>
  <td>Correct</td>
  <td>UTF-8<sup>*</sup></td>
  <td>Correct</td>
  <td>UTF-8<sup>*</sup></td>
  <td>Wrong</td>
  <td>CP1251 (lossy)</td>
</tr>
<tr>
  <td>JavaScript</td>
  <td>Correct</td>
  <td>UTF-8<sup>*</sup></td>
  <td>Correct</td>
  <td>UTF-8<sup>*</sup></td>
  <td>Correct</td>
  <td>UTF-8<sup>*</sup></td>
</tr>
<tr>
  <td>Python</td>
  <td>Correct</td>
  <td>UTF-8<sup>*</sup></td>
  <td>Correct</td>
  <td>UTF-8<sup>*</sup></td>
  <td>Correct</td>
  <td>Error</td>
</tr>
<tr>
  <td>Rust</td>
  <td>Correct</td>
  <td>UTF-8</td>
  <td>Correct</td>
  <td>UTF-8</td>
  <td>Correct</td>
  <td>UTF-8</td>
</tr>
</table>

<sup>*</sup> - the output is transcoded from a different UTF representation.

Correct means that the test message "Привет, κόσμος!" was fully readable in the
terminal output. None of the tested language facilities were able to produce
readable output when piped through the standard `findstr` command on Windows.
Java gave the worst results producing both mojibake and replacement characters
in this case: "╧ЁштхЄ, ??????!". Most other languages produced valid UTF-8
when the output of `findstr` was redirected to a file.

The current paper proposes following C, Go, JavaScript and Rust and preserving
the original encoding (modulo UTF conversion). The only difference compared to
`printf` is that we fix the console output on Windows. Java's approach is
problematic for the following reasons:

* There is a silent data loss for **valid** Unicode code points when the output
    is redirected to a file.
* It is more expensive because of transcoding.
* It may give an unusable result when piped through standard Windows commands
    like `findstr`.
* It transcodes into legacy encodings that are rarely used in practice nowadays.
    For example, usage of CP1251 dropped from 4.3% to 0.8% in the last 12+ years
    ([[ENCODING-TRENDS]]), including a 0.1% drop while the current paper was
    in review.

The full listings of test programs are given in [[#lst]].

Performance {#perf}
===========

All the performance benefits of `std::format` ([[FORMAT]]) automatically carry
over to this proposal. In particular, locale-independence by default reduces
global state and makes formatting more efficient compared to stdio and
iostreams. There are fewer function calls (see [[#binary]]) and no shared
formatting state compared to iostreams.

The following benchmark compares the reference implementation of `print` with
`printf` and `ostream`. This benchmark formats a simple message and prints it to
the output stream redirected to `/dev/null`. It uses the Google Benchmark
library [[GOOGLE-BENCH]] to measure timings:

```c++
#include <cstdio>
#include <iostream>

#include <benchmark/benchmark.h>
#include <fmt/ostream.h>

void printf(benchmark::State& s) {
  while (s.KeepRunning())
    std::printf("The answer is %d.\n", 42);
}
BENCHMARK(printf);

void ostream(benchmark::State& s) {
  std::ios::sync_with_stdio(false);
  while (s.KeepRunning())
    std::cout << "The answer is " << 42 << ".\n";
}
BENCHMARK(ostream);

void print(benchmark::State& s) {
  while (s.KeepRunning())
    fmt::print("The answer is {}.\n", 42);
}
BENCHMARK(print);

void print_cout(benchmark::State& s) {
  std::ios::sync_with_stdio(false);
  while (s.KeepRunning())
    fmt::print(std::cout, "The answer is {}.\n", 42);
}
BENCHMARK(print_cout);

void print_cout_sync(benchmark::State& s) {
  std::ios::sync_with_stdio(true);
  while (s.KeepRunning())
    fmt::print(std::cout, "The answer is {}.\n", 42);
}
BENCHMARK(print_cout_sync);

BENCHMARK_MAIN();
```
<!-- ./benchmark --benchmark_out=out --benchmark_out_format=console > /dev/null -->

The benchmark was compiled with Apple clang version 11.0.0 (clang-1100.0.33.17) 
with `-O3 -DNDEBUG` and run on macOS 10.15.4. Below are the results:

<pre class="language-text">
Run on (8 X 2800 MHz CPU s)
CPU Caches:
  L1 Data 32K (x4)
  L1 Instruction 32K (x4)
  L2 Unified 262K (x4)
  L3 Unified 8388K (x1)
Load Average: 1.83, 1.88, 1.82
---------------------------------------------------------&#8203;-
Benchmark                Time             CPU   Iterations
---------------------------------------------------------&#8203;-
printf                87.0 ns         86.9 ns      7834009
ostream                255 ns          255 ns      2746434
print                 78.4 ns         78.3 ns      9095989
print_cout            89.4 ns         89.4 ns      7702973
print_cout_sync       91.5 ns         91.4 ns      7903889
</pre>

Both `print` and `printf` are ~3 times faster than `cout` even with
synchronization to the standard C streams turned off. `print` is 14% faster when
printing to `stdout` than to `cout`. For this reason and because `print` doesn't
use formatting facilities of `ostream` we propose using `stdout` as the default
output stream and providing an overload for writing to `ostream`.

On Windows 10 with Visual C++ 2019 the results are similar although the
difference between `print` writing to `stdout` and `cout` is smaller with
`stdout` being 7% faster:

<pre class="language-text">
Run on (1 X 2808 MHz CPU )
CPU Caches:
  L1 Data 32K (x1)
  L1 Instruction 32K (x1)
  L2 Unified 262K (x1)
  L3 Unified 8388K (x1)
---------------------------------------------------------&#8203;-
Benchmark                Time             CPU   Iterations
---------------------------------------------------------&#8203;-
printf                 835 ns          816 ns       746667
ostream               2410 ns         2400 ns       280000
print                  580 ns          572 ns      1120000
print_cout             623 ns          614 ns      1120000
print_cout_sync        615 ns          614 ns      1120000
</pre>

Binary code {#binary}
===========

We propose minimizing per-call binary code size by applying the type erasure
mechanism from [[P0645]]. In this approach all the formatting and printing logic
is implemented in a non-variadic function `vprint`. Inline variadic `print`
function only constructs a `format_args` object, representing an array of
type-erased argument references, and passes it to `vprint*`. Here is a
simplified example:

```
void vprint(string_view fmt, format_args args);

template<class... Args>
  inline void print(string_view fmt, const Args&... args) {
    return vprint(fmt, make_format_args(args...));
  }
```

We provide `vprint*` overloads so that users can apply the same technique to
their own code. For example:

```
void vlog(log_level level, string_view fmt, format_args args) {
  // Print the log level and use vprint* overloads to format and print the
  // message.
}

template<class... Args>
  inline void log(log_level level, string_view fmt, const Args&... args) {
    return vlog(level, fmt, make_format_args(args...));
  }
```

Here `vlog` that implements the logging logic is not parameterized on formatting
argument types resulting in less code bloat compared to a naive templated
version. As a real-world example, this technique has been applied in the Folly
Logger ([[FOLLY]]) bringing ~5x binary size reduction per logging function call.

Below we compare the reference implementation of ``print`` to standard
formatting facilities. All the code snippets are compiled with clang (Apple
clang version 11.0.0 clang-1100.0.33.17) with <code highlight="text">
-O3 -DNDEBUG -c -std=c++17</code> and the resulting binaries are disassembled
with <code highlight="text">objdump -S</code>:

```
void printf_test(const char* name) {
  printf("Hello, %s!", name);
}
```

```text
__Z11printf_testPKc:
       0:       55      pushq   %rbp
       1:       48 89 e5        movq    %rsp, %rbp
       4:       48 89 fe        movq    %rdi, %rsi
       7:       48 8d 3d 08 00 00 00    leaq    8(%rip), %rdi
       e:       31 c0   xorl    %eax, %eax
      10:       5d      popq    %rbp
      11:       e9 00 00 00 00  jmp     0 <__Z11printf_testPKc+0x16>
```

```
void ostream_test(const char* name) {
  std::cout << "Hello, " << name << "!";
}
```

```text
__Z12ostream_testPKc:
       0:       55      pushq   %rbp
       1:       48 89 e5        movq    %rsp, %rbp
       4:       41 56   pushq   %r14
       6:       53      pushq   %rbx
       7:       48 89 fb        movq    %rdi, %rbx
       a:       48 8b 3d 00 00 00 00    movq    (%rip), %rdi
      11:       48 8d 35 6c 03 00 00    leaq    876(%rip), %rsi
      18:       ba 07 00 00 00  movl    $7, %edx
      1d:       e8 00 00 00 00  callq   0 <__Z12ostream_testPKc+0x22>
      22:       49 89 c6        movq    %rax, %r14
      25:       48 89 df        movq    %rbx, %rdi
      28:       e8 00 00 00 00  callq   0 <__Z12ostream_testPKc+0x2d>
      2d:       4c 89 f7        movq    %r14, %rdi
      30:       48 89 de        movq    %rbx, %rsi
      33:       48 89 c2        movq    %rax, %rdx
      36:       e8 00 00 00 00  callq   0 <__Z12ostream_testPKc+0x3b>
      3b:       48 8d 35 4a 03 00 00    leaq    842(%rip), %rsi
      42:       ba 01 00 00 00  movl    $1, %edx
      47:       48 89 c7        movq    %rax, %rdi
      4a:       5b      popq    %rbx
      4b:       41 5e   popq    %r14
      4d:       5d      popq    %rbp
      4e:       e9 00 00 00 00  jmp     0 <__Z12ostream_testPKc+0x53>
      53:       66 2e 0f 1f 84 00 00 00 00 00   nopw    %cs:(%rax,%rax)
      5d:       0f 1f 00        nopl    (%rax)
```

```
void print_test(const char* name) {
  print("Hello, {}!", name);
}
```

```text
__Z10print_testPKc:
       0:	55 	pushq	%rbp
       1:	48 89 e5 	movq	%rsp, %rbp
       4:	48 83 ec 10 	subq	$16, %rsp
       8:	48 89 7d f0 	movq	%rdi, -16(%rbp)
       c:	48 8d 3d 19 00 00 00 	leaq	25(%rip), %rdi
      13:	48 8d 4d f0 	leaq	-16(%rbp), %rcx
      17:	be 0a 00 00 00 	movl	$10, %esi
      1c:	ba 0d 00 00 00 	movl	$13, %edx
      21:	e8 00 00 00 00 	callq	0 <__Z10print_testPKc+0x26>
      26:	48 83 c4 10 	addq	$16, %rsp
      2a:	5d 	popq	%rbp
      2b:	c3 	retq
```

The code generated for the `print_test` function that uses the reference
implementation of `print` described in this proposal is more than 2x smaller
than the ostream code and has one function call instead of three. The `printf`
code is further 2x smaller but doesn't have any error handling. Adding error
handling would make its code size closer to that of `print`.

The following factors contribute to the difference in binary code size between
`print` and `printf`:

* Passing format string as `string_view` instead of `const char*`.
* Capturing and passing argument type information.
* Preparing the array of formatting arguments.

Impact on existing code {#impact}
=======================

The current proposal adds new functions to the headers `<print>` and
`<ostream>` and should have no impact on existing code.

Implementation {#impl}
==============

The proposed `print` function has been implemented in the open-source fmt
library [[FMT]] and has been in use for about 6 years.

Rust's standard output facility uses essentially the same approach for
preventing mojibake when printing to console on Windows ([[RUST-STDIO]]).
The main difference is that invalid code units are reported as errors in Rust.

LLVM's `raw_ostream` [[LLVM-OSTREAM]] also implements this approach when writing
to console on Windows. The main difference is that in case of invalid UTF-8 it
falls back on writing raw (not transcoded) data.

Wording {#wording}
=======

Add an entry for `__cpp_lib_print` to section "Header `<version>` synopsis
[[version.syn](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4861.pdf#subsection.17.3.2)]",
in a place that respects the table’s current alphabetic order:

<pre>
<ins>#define __cpp_lib_print  202005L **placeholder**	// also in &lt;format&gt;</ins>
</pre>

Add the header `<print>` to the "C++ library headers" table in [headers], in a
place that respects the table’s current alphabetic order.

<ins>29.7.? Header `<print>` synopsis [print.syn].</ins>

<pre>
<ins>
namespace std {
  template&lt;class... Args&gt;
    void print(<i>&#8203;format-string</i>&lt;Args...> fmt, const Args&... args);
  template&lt;class... Args&gt;
    void print(FILE* stream, <i>&#8203;format-string</i>&lt;Args...> fmt, const Args&... args);

  template&lt;class... Args&gt;
    void println(<i>&#8203;format-string</i>&lt;Args...> fmt, const Args&... args);
  template&lt;class... Args&gt;
    void println(FILE* stream, <i>&#8203;format-string</i>&lt;Args...> fmt, const Args&... args);

  void vprint_unicode(string_view fmt, format_args args);
  void vprint_unicode(FILE* stream, string_view fmt, format_args args);

  void vprint_nonunicode(string_view fmt, format_args args);
  void vprint_nonunicode(FILE* stream, string_view fmt, format_args args);
}
</ins>
</pre>

Modify section "Header `<ostream>` synopsis [[ostream.syn](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4861.pdf#subsection.29.7.2)]":

<pre>
...
template&lt;class charT, class traits, class T&gt;
basic_ostream&lt;charT, traits&gt;& operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&& os, const T& x);
<ins>
template&lt;class... Args&gt;
  void print(ostream& os, <i>&#8203;format-string</i>&lt;Args...> fmt, const Args&... args);
template&lt;class... Args&gt;
  void println(ostream& os, <i>&#8203;format-string</i>&lt;Args...> fmt, const Args&... args);

void vprint_unicode(ostream& os, string_view fmt, format_args args);
void vprint_nonunicode(ostream& os, string_view fmt, format_args args);
</ins>
</pre>

<ins>29.7.? Print functions [print.fun].</ins>

<pre>
<ins>
template&lt;class... Args&gt;
  void print(<i>&#8203;format-string</i>&lt;Args...> fmt, const Args&... args);
</ins>
</pre>
<span class="parnum">26</span> <ins>*Effects:* Equivalent to:
<pre>
<ins>
  print(stdout, fmt, make_format_args(args...));
</ins>
</pre>

<pre>
<ins>
template&lt;class... Args&gt;
  void print(FILE* stream, <i>&#8203;format-string</i>&lt;Args...> fmt, const Args&... args);
</ins>
</pre>
<span class="parnum">27</span> <ins>*Effects:* If string literal encoding is UTF-8, equivalent to:</ins>
<pre>
<ins>
  vprint_unicode(stream, fmt.str, make_format_args(args...));
</ins>
</pre>
<ins>Otherwise, equivalent to:</ins>
<pre>
<ins>
  vprint_nonunicode(stream, fmt.str, make_format_args(args...));
</ins>
</pre>

<pre>
<ins>
template&lt;class... Args&gt;
  void println(<i>&#8203;format-string</i>&lt;Args...> fmt, const Args&... args);
</ins>
</pre>
<span class="parnum">28</span> <ins>*Effects:* Equivalent to:
<pre>
<ins>
  print("{}\n", format(fmt, args...));
</ins>
</pre>

<pre>
<ins>
template&lt;class... Args&gt;
  void println(FILE* stream, <i>&#8203;format-string</i>&lt;Args...> fmt, const Args&... args);
</ins>
</pre>
<span class="parnum">29</span> <ins>*Effects:* Equivalent to:
<pre>
<ins>
  print(stream, "{}\n", format(fmt, args...));
</ins>
</pre>

<pre>
<ins>
void vprint_unicode(string_view fmt, format_args args);
</ins>
</pre>
<span class="parnum">30</span> <ins>*Effects:* *Equivalent to*:</ins>
<pre>
<ins>
  vprint_unicode(stdout, fmt, args));
</ins>
</pre>

<pre>
<ins>
void vprint_unicode(FILE* stream, string_view fmt, format_args args);
</ins>
</pre>
<ins>
<span class="parnum">31</span> *Effects:* Let `out = vformat(fmt, args)`.
If `stream` refers to a terminal [ Note: On POSIX and Windows meaning that
`isatty(fileno(stream))` and `GetConsoleMode(_get_osfhandle(_fileno(stream)), ...)`
return nonzero respectively. — end note ] capable of
displaying Unicode, writes `out` to the terminal using the native Unicode API.
[ Note: On Windows this API is `WriteConsoleW`. — end note ]
If `out` contains invalid code units, the behavior is undefined and
implementations are encouraged to diagnose it.
If this requires transcoding then implementations should substitute invalid code
units with U+FFFD � REPLACEMENT CHARACTER per The Unicode® Standard Version 13.0
– Core Specification, Chapter 3.9. Otherwise writes `out` to `stream` unchanged.
</ins>
<!-- https://www.unicode.org/versions/Unicode13.0.0/ch03.pdf -->
<p>
<ins>
*Throws:* As specified in [[format.err.report](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4861.pdf#subsection.20.20.3)]
or `system_error` if a call by the implementation to an operating system or
other underlying API results in an error that prevents the function from meeting
its specifications.
</ins>

<pre>
<ins>
void vprint_nonunicode(string_view fmt, format_args args);
</ins>
</pre>
<span class="parnum">32</span> <ins>*Effects:* *Equivalent to*:</ins>
<pre>
<ins>
  vprint_nonunicode(stdout, fmt, args));
</ins>
</pre>

<pre>
<ins>
void vprint_nonunicode(FILE* stream, string_view fmt, format_args args);
</ins>
</pre>
<ins>
<span class="parnum">33</span> *Effects:* Writes the result of `vformat(fmt, args)` to `stream`.
</ins>
<p>
<ins>
*Throws:* As specified in [[format.err.report](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4861.pdf#subsection.20.20.3)]
or `system_error` if a call by the implementation to an operating system or
other underlying API results in an error that prevents the function from meeting
its specifications.
</ins>

Add subsection "Print [ostream.formatted.print]" to
"Formatted output functions [[ostream.formatted](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4861.pdf#subsubsection.29.7.5.2)]":

<pre>
<ins>
template&lt;class... Args&gt;
  void print(ostream& os, <i>&#8203;format-string</i>&lt;Args...> fmt, const Args&... args);
</ins>
</pre>
<span class="parnum">1</span> <ins>*Effects:* If string literal encoding is UTF-8, equivalent to:</ins>
<pre>
<ins>
  vprint_unicode(os, fmt, make_format_args(args...));
</ins>
</pre>
<ins>Otherwise, equivalent to:</ins>
<pre>
<ins>
  vprint_nonunicode(os, fmt, make_format_args(args...));
</ins>
</pre>

<pre>
<ins>
void vprint_unicode(ostream& os, string_view fmt, format_args args);
</ins>
</pre>
<ins>
<span class="parnum">2</span> *Effects:* Let `out = vformat(os.getloc(), fmt, args)`. If `os` is a file stream (its
associated stream buffer is an instance of `basic_filebuf`) that refers to a
terminal capable of displaying Unicode, writes `out` transcoded to the native
system Unicode encoding to the terminal using the native API that preserves the
encoding. Otherwise writes `out` to `stream` without transcoding.
</ins>
<p>
<ins>
*Throws:* As specified in [[format.err.report](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4861.pdf#subsection.20.20.3)]
or `system_error` if a call by the implementation to an operating system or
other underlying API results in an error that prevents the function from meeting
its specifications.
</ins>

<pre>
<ins>
void vprint_nonunicode(ostream& os, string_view fmt, format_args args);
</ins>
</pre>
<ins>
<span class="parnum">3</span> *Effects:* Writes the result of `vformat(os.getloc(), fmt, args)` to `os`.
</ins>
<p>
<ins>
*Throws:* As specified in [[format.err.report](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4861.pdf#subsection.20.20.3)]
or `system_error` if a call by the implementation to an operating system or
other underlying API results in an error that prevents the function from meeting
its specifications.
</ins>

Add to Normative references [intro.refs]:

<ins>
– The Unicode® Standard Version 13.0 – Core Specification
</ins>

Appendix A: Unicode tests {#lst}
=========================

This appendix gives full listings of programs for testing Unicode handling in
various formatting facilities as well as test commands and their output on
different platforms. The code contains additional sanity checks to ensure that
the strings are encoded in some form of UTF as opposed to a legacy encoding.

C (`test.c`):

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
  const char* message = "Привет, κόσμος!\n";
  if ((unsigned char)message[0] != 0xD0 && (unsigned char)message[1] != 0x9F)
    abort();
  printf(message);
}
```

Go (`test.go`):

```go
package main

import "fmt"
import "log"

func main() {
  var message = "Привет, κόσμος!"
  if message[0] != 0xD0 && message[1] != 0x9F {
    log.Fatal("wrong encoding")
  }
  fmt.Println(message)
}
```

Java (`Test.java`):

```java
class Test {
  public static void main(String[] args) {
    String message = "Привет, κόσμος!\n";
    if (message.charAt(0) != 0x41F) throw new RuntimeException();
    System.out.print(message);
  }
}
```

JavaScript / Node.js (`test.js`):

```js
message = "Привет, κόσμος!";
if (message.charCodeAt(0) != 0x41F) throw "wrong encoding";
console.log(message);
```

Python (`test.py`):

```python
message = "Привет, κόσμος!"
if ord(message[0]) != 0x41F:
    raise Exception()
print(message)
```

Rust (`test.rs`):

```rust
fn main() {
  if "Привет, κόσμος!".chars().nth(0).unwrap() as u32 != 0x41F {
    panic!();
  }
  println!("Привет, κόσμος!");
}
```

Linux:

```
$ cc test.c -o c-test
$ ./c-test
Привет, κόσμος!
$ ./c-test > out-c-linux.txt

$ go build -o go-test test.go
$ ./go-test
Привет, κόσμος!
$ ./go-test > out-go-linux.txt

$ java Test
Привет, κόσμος!
$ java Test > out-java-linux.txt

$ node test.js
Привет, κόσμος!
$ node test.js > out-js-linux.txt

$ python3 test.py
Привет, κόσμος!
$ python3 test.py > out-py-linux.txt

$ rustc test.rs -o rust-test
$ ./rust-test
Привет, κόσμος!
$ ./rust-test > out-rust-linux.txt
```

All output files are in UTF-8:
* [out-c-linux.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-c-linux.txt)
* [out-go-linux.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-go-linux.txt)
* [out-java-linux.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-java-linux.txt)
* [out-js-linux.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-js-linux.txt)
* [out-py-linux.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-py-linux.txt)
* [out-rust-linux.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-rust-linux.txt)

Linux configuration:

* Ubuntu Focal 20.04 with the ru_RU.UTF-8 locale
* cc: gcc 9.3.0
* go: go1.13.8
* java: openjdk 11.0.9.1
* node: v14.5.0
* python3: 3.7.5
* rustc: 1.47.0

macOS:

```
% cc test.c -o c-test
% ./c-test
Привет, κόσμος!
% ./c-test > out-c-macos.txt

% go build -o test-go test.go
% ./test-go
Привет, κόσμος!
% ./test-go > out-go-macos.txt

% java Test
Привет, κόσμος!
% java Test > out-java-macos.txt

% node test.js
Привет, κόσμος!
% node test.js > out-js-macos.txt

% python3 test.py
Привет, κόσμος!
% python3 test.py > out-py-macos.txt

% rustc test.rs -o rust-test
% ./rust-test
Привет, κόσμος!
% ./rust-test > out-rust-macos.txt
```

All output files are in UTF-8:
* [out-c-macos.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-c-macos.txt)
* [out-go-macos.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-go-macos.txt)
* [out-java-macos.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-java-macos.txt)
* [out-js-macos.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-js-macos.txt)
* [out-py-macos.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-py-macos.txt)
* [out-rust-macos.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-rust-macos.txt)

macOS configuration:

* macOS Catalina 10.15.7 with the ru_RU.UTF-8 locale which is the default for
    Russian
* cc: Apple clang version 12.0.0 (clang-1200.0.32.27)
* go: go1.15.5
* java: openjdk 14.0.1
* node: v14.5.0
* python3: 3.7.5
* rustc: 1.47.0

Windows:

```
>cl /Fe:c-test.exe test.c
...
>c-test
╨Я╤А╨╕╨▓╨╡╤В, ╬║╧М╧Г╬╝╬┐╧В!
>c-test > out-c-windows.txt
>c-test | findstr ,
╨Я╤А╨╕╨▓╨╡╤В, ╬║╧М╧Г╬╝╬┐╧В!

>go build -o go-test.exe test.go
>go-test
Привет, κόσμος!
>go-test > out-go-windows.txt
>go-test | findstr ,
╨Я╤А╨╕╨▓╨╡╤В, ╬║╧М╧Г╬╝╬┐╧В!

>java Test
Привет, ??????!
>java Test > out-java-windows.txt
>java Test | findstr ,
╧ЁштхЄ, ??????!

>node test.js
Привет, κόσμος!
>node test.js > out-js-windows.txt
>node test.js | findstr ,
╨Я╤А╨╕╨▓╨╡╤В, ╬║╧М╧Г╬╝╬┐╧В!

>python test.py
Привет, κόσμος!
>python test.py > out-py-windows.txt
Traceback (most recent call last):
  File "...\test.py", line 4, in <module>
    print(message)
  File "...\Python39\lib\encodings\cp1251.py", line 19, in encode
    return codecs.charmap_encode(input,self.errors,encoding_table)[0]
UnicodeEncodeError: 'charmap' codec can't encode characters in position 8-13: character maps to <undefined>
>python test.py | findstr ,
Traceback (most recent call last):
  File "...\test.py", line 4, in <module>
    print(message)
  File "...\Python39\lib\encodings\cp1251.py", line 19, in encode
    return codecs.charmap_encode(input,self.errors,encoding_table)[0]
UnicodeEncodeError: 'charmap' codec can't encode characters in position 8-13: character maps to <undefined>

>rustc test.rs -o rust-test.exe
>rust-test
Привет, κόσμος!
>rust-test > out-rust-windows.txt
>rust-test | findstr ,
╨Я╤А╨╕╨▓╨╡╤В, ╬║╧М╧Г╬╝╬┐╧В!
```

C, JavaScript (node.js), Rust and Go produced valid UTF-8 when the output was
redirected to files. Java produced a file in the legacy CP1251 encoding with `?`
for non-representable code points. Python failed on transcoding to CP1251.
Output files:
* [out-c-windows.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-c-windows.txt)
* [out-go-windows.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-go-windows.txt)
* [out-java-windows.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-java-windows.txt)
* [out-js-windows.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-js-windows.txt)
* [out-py-windows.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-py-windows.txt)
* [out-rust-windows.txt](https://raw.githubusercontent.com/vitaut/unicode-test/main/out-rust-windows.txt)

Windows configuration:

* Windows 10 10.0.19041 with Russian Region and Language settings
* cl: Microsoft (R) C/C++ Optimizing Compiler Version 19.28.29335
* go: go1.15.6
* java: Java HotSpot(TM) 64-Bit Server VM (build 15.0.1+9-18)
* node: v14.15.3
* python: 3.9.1
* rustc: v14.15.3

Acknowledgements {#ack}
================

Thanks to Corentin Jabot for his work on text encodings in C++ and in particular
[[P1885]] that will simplify implementation of the current proposal.

Thanks to Roger Orr, Peter Brett, Hubert Tong, the BSI C++ panel and Tom
Honermann for their feedback, support, constructive criticism and contributions
to the proposal.

<pre class=biblio>
{
  "CODESEARCH": {
	  "title": "Code search engine website",
	  "authors": ["Andrew Tomazos"],
	  "href": "https://codesearch.isocpp.org"
  },
  "DOTNET-WRITE": {
    "title": ".NET documentation, Console.Write Method",
    "href": "https://docs.microsoft.com/en-us/dotnet/api/system.console.write"
  },
  "FMT": {
    "title": "The fmt library",
    "authors": ["Victor Zverovich"],
    "etAl": true,
    "href": "https://github.com/fmtlib/fmt"
  },
  "FOLLY": {
    "title": "Folly: Facebook Open-source Library",
    "href": "https://github.com/facebook/folly"
  },
  "FORMAT": {
    "title":
    "Working Draft, Standard for Programming Language C++, Formatting [format]",
    "authors": ["Richard Smith"],
    "href": "https://wg21.link/n4861#section.20.20"
  },
  "GO-FMT": {
    "title": "Go Package Documentation, Package fmt",
    "href": "https://golang.org/pkg/fmt/"
  },
  "GOOGLE-BENCH": {
    "title": "Google Benchmark: A microbenchmark support library",
    "href": "https://github.com/google/benchmark"
  },
  "ISO2022": {
    "title": "ISO/IEC 2022 Information technology—Character code structure and extension techniques",
    "href": "https://www.iso.org/standard/22747.html"
  },
  "JAVA-PRINT": {
    "title":
    "Java™ Platform, Standard Edition 7 API Specification, Class PrintStream",
    "href": "https://docs.oracle.com/javase/7/docs/api/java/io/PrintStream.html"
  },
  "LLVM-OSTREAM": {
    "title":
    "The LLVM Compiler Infrastructure repository, raw_ostream",
    "href": "https://github.com/llvm-mirror/llvm/blob/master/lib/Support/raw_ostream.cpp"
  },
  "MSVC-UTF8": {
    "title":
    "Visual C++ Documentation, /utf-8 (Set Source and Executable character sets to UTF-8)",
    "href":
    "https://docs.microsoft.com/en-us/cpp/build/reference/utf-8-set-source-and-executable-character-sets-to-utf-8"
  },
  "N0147": {
    "title":
    "ISO/IEC IS 1989:2001 – Programming language COBOL, 14.8.10 DISPLAY statement",
    "href": "https://web.archive.org/web/20020124065139/http://www.ncits.org/tc_home/j4htm/cobolv200112.zip"
  },
  "N2162": {
    "title":
    "ISO/IEC 1539-1:2018 Information technology — Programming languages — Fortran"
  },
  "N2176": {
    "title":
    "ISO/IEC 9899:2017 Programming languages — C, 7.21.6.3. The fprintf function"
  },
  "P0645": {
    "title": "Text Formatting",
    "authors": ["Victor Zverovich"],
    "href": "https://wg21.link/p0645"
  },
  "P1885": {
    "title": "Naming Text Encodings to Demystify Them",
    "authors": ["Corentin Jabot"],
    "href": "https://wg21.link/p1885"
  },
  "P1868": {
    "title": "🦄 width: clarifying units of width and precision in std::format",
    "authors": ["Victor Zverovich", "Zach Laine"],
    "href": "https://wg21.link/p1868"
  },
  "P2216": {
    "title": "std::format improvements",
    "authors": ["Victor Zverovich"],
    "href": "https://wg21.link/p2216"
  },
  "PERL-PRINTF": {
    "title": "Perl 5 version 30.0 documentation, Language reference, printf",
    "href": "https://perldoc.perl.org/functions/printf.html"
  },
  "PHP-PRINTF": {
    "title": "PHP Manual, Function Reference, printf",
    "href": "https://www.php.net/manual/en/function.printf.php"
  },
  "PY-FUNC": {
    "title": "The Python Standard Library, Built-in Functions",
    "href": "https://docs.python.org/3/library/functions.html"
  },
  "R-PRINT": {
    "title": "R: A Language and Environment for Statistical Computing, Reference Index, printf",
    "authors": ["The R Core Team"],
    "href": "https://cran.r-project.org/doc/manuals/r-release/fullrefman.pdf#page=457"
  },
  "RUBY-PRINT": {
    "title": "Documentation for Ruby, print",
    "href": "https://docs.ruby-lang.org/en/2.7.0/ARGF.html#method-i-print"
  },
  "RUST-PRINT": {
    "title": "The Rust Standard Library, Macro std::print",
    "href": "https://doc.rust-lang.org/std/macro.print.html"
  },
  "RUST-STDIO": {
    "title": "The Rust Programming Language repository, windows_stdio",
    "href": "https://github.com/rust-lang/rust/blob/db492ecd5ba6bd82205612cebb9034710653f0c2/library/std/src/sys/windows/stdio.rs"
  },
  "SWIFT-PRINT": {
    "title": "Swift Standard Library, print",
    "href": "https://developer.apple.com/documentation/swift/1541053-print"
  },
  "WHATWG-CONSOLE": {
    "title": "WHATWG Standards, Console",
    "href": "https://console.spec.whatwg.org/"
  },
  "ENCODING-TRENDS": {
    "title": "Historical yearly trends in the usage statistics of character encodings for websites",
    "href": "https://w3techs.com/technologies/history_overview/character_encoding/ms/y"
  }
}
</pre>
