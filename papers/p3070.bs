<pre class='metadata'>
Title: Formatting enums
Shortname: P3070
Revision: 2
Audience: LEWG
Status: P
Group: WG21
URL:
Editor: Victor Zverovich, victor.zverovich@gmail.com
No abstract: true
Date: 2025-01-08
Markup Shorthands: markdown yes
</pre>

<style type="text/css">
  td {
    vertical-align: middle;
  }
  ins { text-decoration: none; }
  ins code { background: #cfc !important; }

  .poll th, .poll td {
    text-align: right;
    width: 20%;
  }

  .wording ul li::marker {
    content: '– ';
  }
</style>

<p style="text-align: right">
"It is a mistake to think you can solve any major problems just with potatoes."
 ― Douglas Adams
</p>

# Introduction # {#intro}

`std::format`, as introduced in C++20, has significantly improved string
formatting in C++. However, custom formatting for enumeration types currently
requires creating somewhat verbose formatter specializations. This proposal
aims to introduce a more intuitive and simpler method to define custom formats
for enums using `format_as`. When formatting enums as integers it is also more
efficient than a formatter specialization.

# Changes since R1 # {#changes1}

- Added wording.

# Changes since R0 # {#changes0}

- Added the SG16 poll results.

# SG16 Poll # {#polls}

**Poll 3: Forward P3070R0 to LEWG.**

No objection to unanimous consent.

# Motivation and Scope # {#motivation}

Enums are fundamental in C++ for representing sets of named constants. There
is often a need to convert these enums to string representations, especially
for logging, debugging, or interfacing with users. The current methods for
customizing enum formatting in `std::format` are not as user-friendly or
integrated as they could be.

With the introduction of a `format_as` extension for enums, we aim to:

* Simplify the process of defining custom formatting representations for enums.
* Improve enum formatting efficiency.
* Ensure compatibility with existing code and minimal disruption.

Consider the following example:

```c++
namespace kevin_namespacy {
enum class film {
  house_of_cards, american_beauty, se7en = 7
};
}
```

If we want to format this enum as an underlying type with` std::format` we have
two options. The first option is defining a formatter specialization:

```c++
template <>
struct std::formatter<kevin_namespacy::film> : formatter<int> {
  auto format(kevin_namespacy::film f, format_context& ctx) {
    return formatter<int>::format(std::to_underlying(f), ctx);
  }
};
```

The drawback of this option is that even with forwarding to another formatter
there is a fair amount of boilerplate and it cannot be done in the same
namespace.

The second option is converting the enum to the underlying type:

```c++
film f = kevin_namespacy::se7en;
auto s = std::format("{}", std::to_underlying(f));
```

The drawback of the second option is that the conversion has to be done at every
call site.

# Proposed Change # {#proposal}

We propose adding a `format_as` extension point to `std::format`. `format_as`
is a function discovered by the argument-dependent lookup (ADL) that takes an
enum to be formatted as the argument and converts it to an object of another
formattable type, normally an integer or a string.

This significantly improves user experience by eliminating almost all
boilerplate:

**Before:**

```c++
namespace kevin_namespacy {
enum class film {...};
}
template <>
struct std::formatter<kevin_namespacy::film> : formatter<int> {
  auto format(kevin_namespacy::film f, format_context& ctx) const {
    return formatter<int>::format(std::to_underlying(f), ctx);
  }
};
```

**After:**

```c++
namespace kevin_namespacy {
enum class film {...};
auto format_as(film f) { return std::to_underlying(f); }
}
```

The semantics of `format_as` is the same as the corresponding "forwarding"
`formatter` specialization.

`format_as` can be used to format enums as strings as well:

```c++
enum class color {red, green, blue};

auto format_as(color c) -> std::string_view {
  switch (c) {
    case color::red:   return "red";
    case color::green: return "green";
    case color::blue:  return "blue";
  }
}

auto s = std::format("{}", color::red); // s == "red"
```

Apart from usability improvement, if the target type is one of the built-in
types directly supported by `std::format`, formatting can be implemented more
efficiently. Instead of going through the general-purpose `formatter` API the
enum can be converted directly to the built-in type at the call site.
And conversion from an enum to its underlying type is effectively a noop so
there is no effect on the binary size.

The difference can be seen on the following benchmark results for an enum
similar to `std::byte`:

<pre>
---------------------------------------------------------------------
Benchmark                           Time             CPU   Iterations
---------------------------------------------------------------------
BM_Formatter                     17.7 ns         17.7 ns     38037070
BM_FormatAs                      8.90 ns         8.88 ns     79036210
</pre>

Considering that `format_as` has almost 2x better performance, this paper also
proposes making `std::byte` formattable using the new facility.

# Impact on the Standard # {#impact}

This proposal is an additive change to the existing `<format>` standard library
component and does not necessitate alterations to current language features or
core library interfaces. It is a backward-compatible enhancement that addresses
a common use case in `std::format`.

# Wording # {#wording}

<div class="wording">

<!-- Disabling implicit conversions would make enums::format_as not work
     and therefore not proposed. -->

Modify [[format.arg](https://eel.is/c++draft/format.arg)]:

```
template<class T> explicit basic_format_arg(T& v) noexcept;
```

*Constraints*: `T` satisfies *formattable-with*`<Context>`.

*Preconditions*: If `decay_t<T>` is `char_type*` or `const char_type*`,
`static_cast<const char_type*>(v)` points to a NTCTS ([[defns.ntcts](
https://eel.is/c++draft/defns.ntcts)]).

*Effects*: Let `TD` be `remove_const_t<T>`.
<ins>
If `format_as(v)` is a valid expression, let `u` be `format_as(v)` and `U` be
`remove_cvref_t<decltype(u)>`. Otherwise, let `u` be `v` and `U` be `TD`.
</ins>

- If <code><del>TD</del><ins>U</ins></code> is `bool` or `char_type`, initializes
    `value` with <code><del>v</del><ins>u</ins></code>;

- otherwise, if <code><del>TD</del><ins>U</ins></code> is `char` and `char_type` is
    `wchar_t`, initializes `value` with
    <code>static_cast&lt;wchar_t>(static_cast&lt;unsigned char>(<del>v</del><ins>u</ins>))</code>;

- otherwise, if <code><del>TD</del><ins>U</ins></code> is a signed integer type
    ([[basic.fundamental](https://eel.is/c++draft/basic.fundamental)]) and
    <code>sizeof(<del>TD</del><ins>U</ins>) &lt;= sizeof(int)</code>, initializes `value`
    with <code>static_cast<int>(<del>v</del><ins>u</ins>)</code>;

- otherwise, if <code><del>TD</del><ins>U</ins></code> is an unsigned integer type and
    <code>sizeof(<del>TD</del><ins>U</ins>) &lt;= sizeof(unsigned int)</code>,
    initializes `value` with <code>static_cast&lt;unsigned int>(<del>v</del><ins>u</ins>)</code>;

- otherwise, if <code><del>TD</del><ins>U</ins></code> is a signed integer type and
    <code>sizeof(<del>TD</del><ins>U</ins>) &lt;= sizeof(long long int)</code>,
    initializes `value` with <code>static_cast&lt;long long int>(<del>v</del><ins>u</ins>)</code>;

- otherwise, if <code><del>TD</del><ins>U</ins></code> is an unsigned integer type and
    <code>sizeof(<del>TD</del><ins>U</ins>) &lt;= sizeof(unsigned long long int)</code>,
    initializes `value` with <code>static_cast&lt;unsigned long long int>(<del>v</del><ins>u</ins>)</code>;

- otherwise, if <code><del>TD</del><ins>U</ins></code> is a standard floating-point type,
    initializes `value` with <code><del>v</del><ins>u</ins></code>;

- otherwise, if <code><del>TD</del><ins>U</ins></code> is a specialization of
    <code>basic_string_view</code> or <code>basic_string</code><del>
    and</del><ins>,</ins> <code><del>TD</del><ins>U</ins>::​value_type</code>
    is `char_type` <ins>and `format_as(v)` is not a valid expression</ins>,
    initializes `value` with `basic_string_view<char_type>(v.data(), v.size())`;

- otherwise, if <code>decay_t&lt;<del>TD</del><ins>U</ins>&gt;</code> is `char_type*` or
    `const char_type*` <ins>and `format_as(v)` is not a valid expression</ins>,
    initializes `value` with `static_cast<const char_type*>(v)`;

- otherwise, if <code>is_void_v&lt;remove_pointer_t&lt;<del>TD</del><ins>U</ins>&gt;&gt;</code>
    is `true` or `is_null_pointer_v<TD>` is `true`, initializes `value` with
    <code>static_cast&lt;const void*>(<del>v</del><ins>u</ins>)</code>;

- otherwise, initializes `value` with `handle(v)`.

Modify [[format.formatter.spec](https://eel.is/c++draft/format.formatter.spec)]:

The functions defined in [[format.functions](
https://eel.is/c++draft/format.functions)] use specializations of the class
template formatter to format individual arguments.

Let `charT` be either `char` or `wchar_t`. Each specialization of `formatter`
is either enabled or disabled, as described below. A *debug-enabled*
specialization of `formatter` additionally provides a public, constexpr,
non-static member function `set_debug_format()` which modifies the state of
the `formatter` to be as if the type of the *std-format-spec* parsed by the
last call to `parse` were `?`. Each header that declares the template
`formatter` provides the following enabled specializations:

- The debug-enabled specializations

    ```
    template<> struct formatter<char, char>;
    template<> struct formatter<char, wchar_t>;
    template<> struct formatter<wchar_t, wchar_t>;
    ```

    ...

The `parse` member functions of these formatters interpret the format
specification as a *std-format-spec* as described in [[format.string.std](
https://eel.is/c++draft/format.string.std)].

<ins>
Let *format-as-type*`<T>` for type `T` be
`remove_cvref_t<decltype(format_as(declval<const T&>()))>`.
Each header that declares the template `formatter` provides the following
enabled specialization:
</ins>

<pre>
<ins>template&lt;class T, class charT>
  requires (formattable&lt;<i>format-as-type</i>&lt;T>>)
struct formatter&lt;T, charT> {
 private:
  formatter&lt;<i>format-as-type</i>&lt;T>> <i>fmt_</i>;  <i>// exposition-only</i>

 public:
  constexpr format_parse_context::iterator parse(format_parse_context& ctx);

  template &lt;typename FormatContext>
    typename FormatContext::iterator format(const T& val, FormatContext& ctx) const;
};</ins>
</pre>

<pre>
<ins>constexpr format_parse_context::iterator parse(format_parse_context& ctx);</ins>
</pre>

<ins>
*Returns*: <code><i>fmt_</i>.parse(ctx);</code>.

<pre>
<ins>template &lt;typename FormatContext>
  typename FormatContext::iterator format(const T& val, FormatContext& ctx) const;</ins>
</pre>

<ins>
*Returns*: <code><i>fmt_</i>.format(format_as(val), ctx)</code>.
</ins>

<!-- TODO: set_debug_format -->

</div>

# Alternatives Considered # {#alt}

Another option is to use the `format_kind` extension point:

```
namespace kevin_namespacy {
enum class film {
  house_of_cards, american_beauty, se7en = 7
};
}

template<>
std::format_as std::format_kind<kevin_namespacy::film> =
  [](kevin_namespacy::film f) {
    return std::to_underlying(f);
  };
```

where `format_as` is

```
template <typename F>
struct format_as {
   F f;

   template<typename T>
   constexpr decltype(auto) operator()(T&& t) const {
     return std::invoke(f, std::forward<T>(t));
   }
};
```

The benefit of this approach is that we don't need to introduce another
extension point but unfortunately it has a number of drawbacks compared to the
ADL-based one:

* It's more cumbersome to use.
* There is an extra level of indirection and at least debug codegen will be
    worse.
* It doesn't allow specifying a single conversion for all enums in a namespace
    which, based on usage experience in {fmt}, is an important use case.

For these reasons it is not proposed in the current paper.

# Implementation # {#impl}

The proposed extension API has been implemented in the open-source {fmt} library
([[FMT]]) and as of January 2025 has been shipping for three major versions.
It has been extended to all user-defined types and not just enums but this is
not proposed in the current paper since usage experience is still limited.

# Acknowledgements # {#ack}

Thanks to Tomasz Kamiński for providing useful feedback and suggesting an
alternative extension API.

# Appendix A: Benchmark # {#appendix}

This appendix gives the source code of the benchmark used for comparing
performance of `format_as` with a `formatter` specialization.

```c++
#include <benchmark/benchmark.h>
#include <fmt/core.h>

enum class byte_for_formatter : unsigned char {};

template <>
struct fmt::formatter<byte_for_formatter> : fmt::formatter<unsigned char> {
  auto format(byte_for_formatter b, fmt::format_context& ctx) {
    return fmt::formatter<unsigned char>::format(
      static_cast<unsigned char>(b), ctx);
  }
};

enum class byte_for_format_as : unsigned char {};

auto format_as(byte_for_format_as b) { return static_cast<unsigned char>(b); }

static void BM_Formatter(benchmark::State& state) {
  auto b = byte_for_formatter();
  for (auto _ : state) {
    std::string formatted = fmt::format("{}", b);
    benchmark::DoNotOptimize(formatted);
  }
}
BENCHMARK(BM_Formatter);

static void BM_FormatAs(benchmark::State& state) {
  auto b = byte_for_format_as();
  for (auto _ : state) {
    std::string formatted = fmt::format("{}", b);
    benchmark::DoNotOptimize(formatted);
  }
}
BENCHMARK(BM_FormatAs);

BENCHMARK_MAIN();
```

<pre class=biblio>
{
  "FMT": {
    "title": "The {fmt} library",
    "authors": ["Victor Zverovich"],
    "etAl": true,
    "href": "https://github.com/fmtlib/fmt"
  }
}
</pre>
