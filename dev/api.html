
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="usage.html">
      
      
        <link rel="next" href="syntax.html">
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.25">
    
    
      
        <title>API - {fmt}</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.6543a935.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#api-reference-string-formatting-api" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="index.html" title="{fmt}" class="md-header__button md-logo" aria-label="{fmt}" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            {fmt}
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              API
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
    
      <div class="md-header__source">
        <a href="https://github.com/fmtlib/fmt" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="usage.html" class="md-tabs__link">
        
  
    
  
  Usage

      </a>
    </li>
  

      
        
  
  
    
  
  
    <li class="md-tabs__item md-tabs__item--active">
      <a href="api.html" class="md-tabs__link">
        
  
    
  
  API

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="syntax.html" class="md-tabs__link">
        
  
    
  
  Syntax

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="index.html" class="md-tabs__link">
        
  
    
  
  

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


  

<nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="index.html" title="{fmt}" class="md-nav__button md-logo" aria-label="{fmt}" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    {fmt}
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/fmtlib/fmt" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="usage.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Usage
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    API
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="api.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#base-api" class="md-nav__link">
    <span class="md-ellipsis">
      Base API
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Base API">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#compile-time-format-string-checks" class="md-nav__link">
    <span class="md-ellipsis">
      Compile-Time Format String Checks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#formatting-user-defined-types-udt" class="md-nav__link">
    <span class="md-ellipsis">
      Formatting User-Defined Types {#udt}
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named-arguments" class="md-nav__link">
    <span class="md-ellipsis">
      Named Arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#argument-lists" class="md-nav__link">
    <span class="md-ellipsis">
      Argument Lists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dynamic-argument-lists-args-api" class="md-nav__link">
    <span class="md-ellipsis">
      Dynamic Argument Lists {#args-api}
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compatibility" class="md-nav__link">
    <span class="md-ellipsis">
      Compatibility
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#format-api" class="md-nav__link">
    <span class="md-ellipsis">
      Format API
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Format API">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#literal-based-api" class="md-nav__link">
    <span class="md-ellipsis">
      Literal-Based API
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utilities" class="md-nav__link">
    <span class="md-ellipsis">
      Utilities
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#system-errors" class="md-nav__link">
    <span class="md-ellipsis">
      System Errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#custom-allocators" class="md-nav__link">
    <span class="md-ellipsis">
      Custom Allocators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#locale" class="md-nav__link">
    <span class="md-ellipsis">
      Locale
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#legacy-compile-time-format-string-checks-legacy-checks" class="md-nav__link">
    <span class="md-ellipsis">
      Legacy Compile-Time Format String Checks {#legacy-checks}
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#range-and-tuple-formatting-ranges-api" class="md-nav__link">
    <span class="md-ellipsis">
      Range and Tuple Formatting {#ranges-api}
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#date-and-time-formatting-chrono-api" class="md-nav__link">
    <span class="md-ellipsis">
      Date and Time Formatting {#chrono-api}
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#standard-library-types-formatting-std-api" class="md-nav__link">
    <span class="md-ellipsis">
      Standard Library Types Formatting {#std-api}
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Standard Library Types Formatting {#std-api}">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#formatting-variants" class="md-nav__link">
    <span class="md-ellipsis">
      Formatting Variants
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#format-string-compilation-compile-api" class="md-nav__link">
    <span class="md-ellipsis">
      Format String Compilation {#compile-api}
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#terminal-color-and-text-style-color-api" class="md-nav__link">
    <span class="md-ellipsis">
      Terminal Color and Text Style {#color-api}
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#system-apis-os-api" class="md-nav__link">
    <span class="md-ellipsis">
      System APIs {#os-api}
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stdostream-support-ostream-api" class="md-nav__link">
    <span class="md-ellipsis">
      std::ostream Support {#ostream-api}
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#printf-formatting-printf-api" class="md-nav__link">
    <span class="md-ellipsis">
      printf Formatting {#printf-api}
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#wchar_t-support-xchar-api" class="md-nav__link">
    <span class="md-ellipsis">
      wchar_t Support {#xchar-api}
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#compatibility-with-c20-stdformat" class="md-nav__link">
    <span class="md-ellipsis">
      Compatibility with C++20 std::format
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="syntax.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Syntax
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="api-reference-string-formatting-api">API Reference {#string-formatting-api}</h1>
<p>The {fmt} library API consists of the following parts:</p>
<ul>
<li><a href="#base-api"><code>fmt/base.h</code></a>: the base API providing main formatting functions
  for <code>char</code>/UTF-8 with C++20 compile-time checks and minimal dependencies</li>
<li><a href="#format-api"><code>fmt/format.h</code></a>: the full format API providing additional
  formatting functions and locale support</li>
<li><a href="#ranges-api"><code>fmt/ranges.h</code></a>: formatting of ranges and tuples</li>
<li><a href="#chrono-api"><code>fmt/chrono.h</code></a>: date and time formatting</li>
<li><a href="#std-api"><code>fmt/std.h</code></a>: formatters for standard library types</li>
<li><a href="#compile-api"><code>fmt/compile.h</code></a>: format string compilation</li>
<li><a href="#color-api"><code>fmt/color.h</code></a>: terminal color and text style</li>
<li><a href="#os-api"><code>fmt/os.h</code></a>: system APIs</li>
<li><a href="#ostream-api"><code>fmt/ostream.h</code></a>: <code>std::ostream</code> support</li>
<li><a href="#args-api"><code>fmt/args.h</code></a>: dynamic argument lists</li>
<li><a href="#printf-api"><code>fmt/printf.h</code></a>: <code>printf</code> formatting</li>
<li><a href="#xchar-api"><code>fmt/xchar.h</code></a>: optional <code>wchar_t</code> support</li>
</ul>
<p>All functions and types provided by the library reside in namespace <code>fmt</code>
and macros have prefix <code>FMT_</code>.</p>
<h2 id="base-api">Base API</h2>
<p><code>fmt/base.h</code> defines the base API which provides main formatting functions
for <code>char</code>/UTF-8 with C++20 compile-time checks. It has minimal include
dependencies for better compile times. This header is only beneficial when
using {fmt} as a library (the default) and not in the header-only mode.
It also provides <code>formatter</code> specializations for the following types:</p>
<ul>
<li><code>int</code>, <code>unsigned</code>, <code>long long</code>, <code>unsigned long long</code></li>
<li><code>float</code>, <code>double</code>, <code>long double</code></li>
<li><code>bool</code></li>
<li><code>char</code></li>
<li><code>const char*</code>, <code>fmt::string_view</code></li>
<li><code>const void*</code></li>
</ul>
<p>The following functions use <a href="syntax.html">format string syntax</a> similar to that
of <a href="https://docs.python.org/3/library/stdtypes.html#str.format">str.format</a>
in Python. They take <em>fmt</em> and <em>args</em> as arguments.</p>
<p><em>fmt</em> is a format string that contains literal text and replacement fields
surrounded by braces <code>{}</code>. The fields are replaced with formatted arguments
in the resulting string. [\~fmt::format_string]{.title-ref} is a format string
which can be implicitly constructed from a string literal or a <code>constexpr</code>
string and is checked at compile time in C++20. To pass a runtime format
string wrap it in [fmt::runtime]{.title-ref}.</p>
<p><em>args</em> is an argument list representing objects to be formatted.</p>
<p>I/O errors are reported as <a href="https://en.cppreference.com/w/cpp/error/system_error"><code>std::system_error</code></a> exceptions unless
specified otherwise.</p>
<p><a id="print"></a>
</p>
<pre><code>void print(format_string<T...> fmt, T&&... args);</code></pre>
<p>Formats <code>args</code> according to specifications in <code>fmt</code> and writes the output to <code>stdout</code>.</p>
<p><b>Example</b>: <pre><code>fmt::print("Elapsed time: {0:.2f} seconds", 1.23);
</code></pre> </p>
        <pre><code>void vprint(string_view fmt, format_args args);</code></pre>
<pre><code>void print(FILE* f, format_string<T...> fmt, T&&... args);</code></pre>
<p>Formats <code>args</code> according to specifications in <code>fmt</code> and writes the output to the file <code>f</code>.</p>
<p><b>Example</b>: <pre><code>fmt::print(stderr, "Don't {}!", "panic");
</code></pre> </p>
        <pre><code>void vprint(FILE* f, string_view fmt, format_args args);</code></pre>
<pre><code>void println(format_string<T...> fmt, T&&... args);</code></pre>
<p>Formats <code>args</code> according to specifications in <code>fmt</code> and writes the output to <code>stdout</code> followed by a newline. </p>
        <pre><code>void println(FILE* f, format_string<T...> fmt, T&&... args);</code></pre>
<p>Formats <code>args</code> according to specifications in <code>fmt</code> and writes the output to the file <code>f</code> followed by a newline. </p>
        <pre><code>auto format_to(OutputIt&& out, format_string<T...> fmt, T&&... args);</code></pre>
<p><pre><code>embed:rst
Formats ``args`` according to specifications in ``fmt``, writes the result to
the output iterator ``out`` and returns the iterator past the end of the output
range. `format_to` does not append a terminating null character.

**Example**::

  auto out = std::vector<char>();
  fmt::format_to(std::back_inserter(out), "{}", 42);
</code></pre> </p>
        <pre><code>auto format_to_n(OutputIt out, size_t n, format_string<T...> fmt, T&&... args);</code></pre>
<p><pre><code>embed:rst
Formats ``args`` according to specifications in ``fmt``, writes up to ``n``
characters of the result to the output iterator ``out`` and returns the total
(not truncated) output size and the iterator past the end of the output range.
`format_to_n` does not append a terminating null character.
</code></pre> </p>
        <pre><code>auto formatted_size(format_string<T...> fmt, T&&... args);</code></pre>
<p>Returns the number of chars in the output of <code>format(fmt, args...)</code>. </p>
        <pre><code>struct format_to_n_result;</code></pre>
<h3 id="compile-time-format-string-checks">Compile-Time Format String Checks</h3>
<p>Compile-time format string checks are enabled by default on compilers
that support C++20 <code>consteval</code>. On older compilers you can use the
<code>FMT_STRING &lt;legacy-checks&gt;</code>{.interpreted-text role="ref"}: macro
defined in <code>fmt/format.h</code> instead.</p>
<p>Unused arguments are allowed as in Python's <code>str.format</code> and ordinary functions.</p>
<pre><code>class basic_format_string;</code></pre>
<p>:: {.doxygentypedef}
fmt::format_string
::</p>
<pre><code>auto runtime(string_view s);</code></pre>
<p><pre><code>embed:rst
Creates a runtime format string.

**Example**::

  // Check format string at runtime instead of compile-time.
  fmt::print(fmt::runtime("{:d}"), "I am not a number");
</code></pre> </p>
        <h3 id="formatting-user-defined-types-udt">Formatting User-Defined Types {#udt}</h3>
<p>The {fmt} library provides formatters for many standard C++ types.
See <a href="#ranges-api"><code>fmt/ranges.h</code></a> for ranges and tuples including standard
containers such as <code>std::vector</code>, <a href="#chrono-api"><code>fmt/chrono.h</code></a> for date and
time formatting and <a href="#std-api"><code>fmt/std.h</code></a> for other standard library types.</p>
<p>There are two ways to make a user-defined type formattable: providing a
<code>format_as</code> function or specializing the <code>formatter</code> struct template.</p>
<p>Use <code>format_as</code> if you want to make your type formattable as some other
type with the same format specifiers. The <code>format_as</code> function should
take an object of your type and return an object of a formattable type.
It should be defined in the same namespace as your type.</p>
<p>Example (<a href="https://godbolt.org/z/nvME4arz8">run</a>):</p>
<div class="language-text highlight"><pre><span></span><code>#include &lt;fmt/format.h&gt;

namespace kevin_namespacy {
enum class film {
  house_of_cards, american_beauty, se7en = 7
};
auto format_as(film f) { return fmt::underlying(f); }
}

int main() {
  fmt::print(&quot;{}\n&quot;, kevin_namespacy::film::se7en); // prints &quot;7&quot;
}
</code></pre></div>
<p>Using specialization is more complex but gives you full control over
parsing and formatting. To use this method specialize the <code>formatter</code>
struct template for your type and implement <code>parse</code> and <code>format</code>
methods.</p>
<p>The recommended way of defining a formatter is by reusing an existing
one via inheritance or composition. This way you can support standard
format specifiers without implementing them yourself. For example:</p>
<div class="language-text highlight"><pre><span></span><code>// color.h:
#include &lt;fmt/base.h&gt;

enum class color {red, green, blue};

template &lt;&gt; struct fmt::formatter&lt;color&gt;: formatter&lt;string_view&gt; {
  // parse is inherited from formatter&lt;string_view&gt;.

  auto format(color c, format_context&amp; ctx) const
    -&gt; format_context::iterator;
};

// color.cc:
#include &quot;color.h&quot;
#include &lt;fmt/format.h&gt;

auto fmt::formatter&lt;color&gt;::format(color c, format_context&amp; ctx) const
    -&gt; format_context::iterator {
  string_view name = &quot;unknown&quot;;
  switch (c) {
  case color::red:   name = &quot;red&quot;; break;
  case color::green: name = &quot;green&quot;; break;
  case color::blue:  name = &quot;blue&quot;; break;
  }
  return formatter&lt;string_view&gt;::format(name, ctx);
}
</code></pre></div>
<p>Note that <code>formatter&lt;string_view&gt;::format</code> is defined in <code>fmt/format.h</code>
so it has to be included in the source file. Since <code>parse</code> is inherited
from <code>formatter&lt;string_view&gt;</code> it will recognize all string format
specifications, for example</p>
<div class="language-c++ highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;{:&gt;10}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="o">::</span><span class="n">blue</span><span class="p">)</span>
</span></code></pre></div>
<p>will return <code>"      blue"</code>.</p>
<p>The experimental <code>nested_formatter</code> provides an easy way of applying a
formatter to one or more subobjects.</p>
<p>For example:</p>
<div class="language-text highlight"><pre><span></span><code>#include &lt;fmt/format.h&gt;

struct point {
  double x, y;
};

template &lt;&gt;
struct fmt::formatter&lt;point&gt; : nested_formatter&lt;double&gt; {
  auto format(point p, format_context&amp; ctx) const {
    return write_padded(ctx, [=](auto out) {
      return format_to(out, &quot;({}, {})&quot;, this-&gt;nested(p.x),
                       this-&gt;nested(p.y));
    });
  }
};

int main() {
  fmt::print(&quot;[{:&gt;20.2f}]&quot;, point{1, 2});
}
</code></pre></div>
<p>prints:</p>
<div class="language-text highlight"><pre><span></span><code>[          (1.00, 2.00)]
</code></pre></div>
<p>Notice that fill, align and width are applied to the whole object which
is the recommended behavior while the remaining specifiers apply to
elements.</p>
<p>In general the formatter has the following form:</p>
<div class="language-text highlight"><pre><span></span><code>template &lt;&gt; struct fmt::formatter&lt;T&gt; {
  // Parses format specifiers and stores them in the formatter.
  //
  // [ctx.begin(), ctx.end()) is a, possibly empty, character range that
  // contains a part of the format string starting from the format
  // specifications to be parsed, e.g. in
  //
  //   fmt::format(&quot;{:f} continued&quot;, ...);
  //
  // the range will contain &quot;f} continued&quot;. The formatter should parse
  // specifiers until &#39;}&#39; or the end of the range. In this example the
  // formatter should parse the &#39;f&#39; specifier and return an iterator
  // pointing to &#39;}&#39;.
  constexpr auto parse(format_parse_context&amp; ctx)
    -&gt; format_parse_context::iterator;

  // Formats value using the parsed format specification stored in this
  // formatter and writes the output to ctx.out().
  auto format(const T&amp; value, format_context&amp; ctx) const
    -&gt; format_context::iterator;
};
</code></pre></div>
<p>It is recommended to at least support fill, align and width that apply
to the whole object and have the same semantics as in standard
formatters.</p>
<p>You can also write a formatter for a hierarchy of classes:</p>
<div class="language-text highlight"><pre><span></span><code>// demo.h:
#include &lt;type_traits&gt;
#include &lt;fmt/core.h&gt;

struct A {
  virtual ~A() {}
  virtual std::string name() const { return &quot;A&quot;; }
};

struct B : A {
  virtual std::string name() const { return &quot;B&quot;; }
};

template &lt;typename T&gt;
struct fmt::formatter&lt;T, std::enable_if_t&lt;std::is_base_of&lt;A, T&gt;::value, char&gt;&gt; :
    fmt::formatter&lt;std::string&gt; {
  auto format(const A&amp; a, format_context&amp; ctx) const {
    return fmt::formatter&lt;std::string&gt;::format(a.name(), ctx);
  }
};

// demo.cc:
#include &quot;demo.h&quot;
#include &lt;fmt/format.h&gt;

int main() {
  B b;
  A&amp; a = b;
  fmt::print(&quot;{}&quot;, a); // prints &quot;B&quot;
}
</code></pre></div>
<p>Providing both a <code>formatter</code> specialization and a <code>format_as</code> overload
is disallowed.</p>
<h3 id="named-arguments">Named Arguments</h3>
<pre><code>auto arg(const Char* name, const T& arg);</code></pre>
<p>Returns a named argument to be used in a formatting function. It should only be used in a call to a formatting function or <code>dynamic_format_arg_store::push_back</code>.</p>
<p>Example**::</p>
<p>fmt::print("Elapsed time: {s:.2f} seconds", fmt::arg("s", 1.23)); </p>
        <p>Named arguments are not supported in compile-time checks at the moment.</p>
<h3 id="argument-lists">Argument Lists</h3>
<p>You can create your own formatting function with compile-time checks and
small binary footprint, for example (<a href="https://godbolt.org/z/vajfWEG4b">https://godbolt.org/z/vajfWEG4b</a>):</p>
<div class="language-c++ highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fmt/base.h&gt;</span>
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a><span class="kt">void</span><span class="w"> </span><span class="nf">vlog</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">format</span><span class="p">,</span>
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a><span class="w">          </span><span class="n">fmt</span><span class="o">::</span><span class="n">format_args</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a><span class="w">  </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;{}: {}: &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span>
</span><span id="__span-1-6"><a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a><span class="w">  </span><span class="n">fmt</span><span class="o">::</span><span class="n">vprint</span><span class="p">(</span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
</span><span id="__span-1-7"><a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a><span class="p">}</span>
</span><span id="__span-1-8"><a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a>
</span><span id="__span-1-9"><a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
</span><span id="__span-1-10"><a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a><span class="kt">void</span><span class="w"> </span><span class="n">log</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">format_string</span><span class="o">&lt;</span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-1-11"><a id="__codelineno-1-11" name="__codelineno-1-11" href="#__codelineno-1-11"></a><span class="w">  </span><span class="n">vlog</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">make_format_args</span><span class="p">(</span><span class="n">args</span><span class="p">...));</span>
</span><span id="__span-1-12"><a id="__codelineno-1-12" name="__codelineno-1-12" href="#__codelineno-1-12"></a><span class="p">}</span>
</span><span id="__span-1-13"><a id="__codelineno-1-13" name="__codelineno-1-13" href="#__codelineno-1-13"></a>
</span><span id="__span-1-14"><a id="__codelineno-1-14" name="__codelineno-1-14" href="#__codelineno-1-14"></a><span class="cp">#define MY_LOG(format, ...) log(__FILE__, __LINE__, format, __VA_ARGS__)</span>
</span><span id="__span-1-15"><a id="__codelineno-1-15" name="__codelineno-1-15" href="#__codelineno-1-15"></a>
</span><span id="__span-1-16"><a id="__codelineno-1-16" name="__codelineno-1-16" href="#__codelineno-1-16"></a><span class="n">MY_LOG</span><span class="p">(</span><span class="s">&quot;invalid squishiness: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
</span></code></pre></div>
<p>Note that <code>vlog</code> is not parameterized on argument types which improves
compile times and reduces binary code size compared to a fully
parameterized version.</p>
<pre><code>constexpr auto make_format_args(T&... args);</code></pre>
<p><pre><code>embed:rst
Constructs an object that stores references to arguments and can be implicitly
converted to `~fmt::format_args`. `Context` can be omitted in which case it
defaults to `~fmt::format_context`. See `~fmt::arg` for lifetime
considerations.
</code></pre> </p>
        <pre><code>class basic_format_args;</code></pre>
<p>A view of a collection of formatting arguments. To avoid lifetime issues it should only be used as a parameter type in type-erased functions such as <code>vformat</code>:</p>
<p><pre><code>void vlog(string_view format_str, format_args args);  // OK
format_args args = make_format_args();  // Error: dangling reference
</code></pre> </p>
    <p>:: {.doxygentypedef}
fmt::format_args
::</p>
<p>:: {.doxygenclass members=""}
fmt::basic_format_arg
::</p>
<p>:: {.doxygenclass members=""}
fmt::basic_format_parse_context
::</p>
<p>:: {.doxygenclass members=""}
fmt::context
::</p>
<p>:: {.doxygentypedef}
fmt::format_context
::</p>
<h3 id="dynamic-argument-lists-args-api">Dynamic Argument Lists {#args-api}</h3>
<p>The header <code>fmt/args.h</code> provides <code>dynamic_format_arg_store</code>, a
builder-like API that can be used to construct format argument lists
dynamically.</p>
<p>:: {.doxygenclass members=""}
fmt::dynamic_format_arg_store
::</p>
<h3 id="compatibility">Compatibility</h3>
<p>:: {.doxygenclass members=""}
fmt::basic_string_view
::</p>
<p>:: {.doxygentypedef}
fmt::string_view
::</p>
<h2 id="format-api">Format API</h2>
<p><code>fmt/format.h</code> defines the full format API providing additional
formatting functions and locale support.</p>
<p><a id="format"></a>
</p>
<pre><code>auto format(format_string<T...> fmt, T&&... args);</code></pre>
<p><pre><code>embed:rst
Formats ``args`` according to specifications in ``fmt`` and returns the result
as a string.

**Example**::

  #include <fmt/core.h>
  std::string message = fmt::format("The answer is {}.", 42);
</code></pre> </p>
        <pre><code>auto vformat(string_view fmt, format_args args);</code></pre>
<h3 id="literal-based-api">Literal-Based API</h3>
<p>The following user-defined literals are defined in <code>fmt/format.h</code>.</p>
<pre><code>constexpr auto operator""_a();</code></pre>
<p><pre><code>embed:rst
User-defined literal equivalent of :func:`fmt::arg`.

**Example**::

  using namespace fmt::literals;
  fmt::print("Elapsed time: {s:.2f} seconds", "s"_a=1.23);
</code></pre> </p>
        <h3 id="utilities">Utilities</h3>
<pre><code>auto ptr(T p);</code></pre>
<p><pre><code>embed:rst
Converts ``p`` to ``const void*`` for pointer formatting.

**Example**::

  auto s = fmt::format("{}", fmt::ptr(p));
</code></pre> </p>
        <pre><code>constexpr auto underlying(Enum e);</code></pre>
<p><pre><code>embed:rst
Converts ``e`` to the underlying type.

**Example**::

  enum class color { red, green, blue };
  auto s = fmt::format("{}", fmt::underlying(color::red));
</code></pre> </p>
        <pre><code>auto to_string(const T& value);</code></pre>
<p><pre><code>embed:rst
Converts *value* to ``std::string`` using the default format for type *T*.

**Example**::

  #include <fmt/format.h>

  std::string answer = fmt::to_string(42);
</code></pre> </p>
        <pre><code>auto group_digits(T value);</code></pre>
<p><pre><code>embed:rst
Returns a view that formats an integer value using ',' as a locale-independent
thousands separator.

**Example**::

  fmt::print("{}", fmt::group_digits(12345));
  // Output: "12,345"
</code></pre> </p>
        <p>:: {.doxygenclass members=""}
fmt::detail::buffer
::</p>
<pre><code>class basic_memory_buffer;</code></pre>
<p><pre><code>embed:rst
A dynamically growing memory buffer for trivially copyable/constructible types
with the first ``SIZE`` elements stored in the object itself.

You can use the ``memory_buffer`` type alias for ``char`` instead.

**Example**::

   auto out = fmt::memory_buffer();
   fmt::format_to(std::back_inserter(out), "The answer is {}.", 42);

This will append the following output to the ``out`` object:

.. code-block:: none

   The answer is 42.

The output can be converted to an ``std::string`` with ``to_string(out)``.
</code></pre> </p>
    <h3 id="system-errors">System Errors</h3>
<p>{fmt} does not use <code>errno</code> to communicate errors to the user, but it may
call system functions which set <code>errno</code>. Users should not make any
assumptions about the value of <code>errno</code> being preserved by library
functions.</p>
<pre><code>auto system_error(int error_code, format_string<T...> fmt, T&&... args);</code></pre>
<p><pre><code>embed:rst
Constructs :class:`std::system_error` with a message formatted with
``fmt::format(fmt, args...)``.
*error_code* is a system error code as given by ``errno``.

**Example**::

  // This throws std::system_error with the description
  //   cannot open file 'madeup': No such file or directory
  // or similar (system message may vary).
  const char* filename = "madeup";
  std::FILE* file = std::fopen(filename, "r");
  if (!file)
    throw fmt::system_error(errno, "cannot open file '{}'", filename);
</code></pre> </p>
        <pre><code>void format_system_error(detail::buffer<char>& out, int error_code, const char* message);</code></pre>
<p><pre><code>embed:rst
Formats an error message for an error returned by an operating system or a
language runtime, for example a file opening error, and writes it to *out*.
The format is the same as the one used by ``std::system_error(ec, message)``
where ``ec`` is ``std::error_code(error_code, std::generic_category()})``.
It is implementation-defined but normally looks like:

.. parsed-literal::
   *<message>*: *<system-message>*

where *<message>* is the passed message and *<system-message>* is the system
message corresponding to the error code.
*error_code* is a system error code as given by ``errno``.
</code></pre> </p>
        <h3 id="custom-allocators">Custom Allocators</h3>
<p>The {fmt} library supports custom dynamic memory allocators. A custom
allocator class can be specified as a template argument to
<code>fmt::basic_memory_buffer</code>{.interpreted-text role="class"}:</p>
<div class="language-text highlight"><pre><span></span><code>using custom_memory_buffer = 
  fmt::basic_memory_buffer&lt;char, fmt::inline_buffer_size, custom_allocator&gt;;
</code></pre></div>
<p>It is also possible to write a formatting function that uses a custom
allocator:</p>
<div class="language-text highlight"><pre><span></span><code>using custom_string =
  std::basic_string&lt;char, std::char_traits&lt;char&gt;, custom_allocator&gt;;

custom_string vformat(custom_allocator alloc, fmt::string_view format_str,
                      fmt::format_args args) {
  auto buf = custom_memory_buffer(alloc);
  fmt::vformat_to(std::back_inserter(buf), format_str, args);
  return custom_string(buf.data(), buf.size(), alloc);
}

template &lt;typename ...Args&gt;
inline custom_string format(custom_allocator alloc,
                            fmt::string_view format_str,
                            const Args&amp; ... args) {
  return vformat(alloc, format_str, fmt::make_format_args(args...));
}
</code></pre></div>
<p>The allocator will be used for the output container only. Formatting
functions normally don\'t do any allocations for built-in and string
types except for non-default floating-point formatting that occasionally
falls back on <code>sprintf</code>.</p>
<h3 id="locale">Locale</h3>
<p>All formatting is locale-independent by default. Use the <code>'L'</code> format
specifier to insert the appropriate number separator characters from the
locale:</p>
<div class="language-text highlight"><pre><span></span><code>#include &lt;fmt/core.h&gt;
#include &lt;locale&gt;

std::locale::global(std::locale(&quot;en_US.UTF-8&quot;));
auto s = fmt::format(&quot;{:L}&quot;, 1000000);  // s == &quot;1,000,000&quot;
</code></pre></div>
<p><code>fmt/format.h</code> provides the following overloads of formatting functions
that take <code>std::locale</code> as a parameter. The locale type is a template
parameter to avoid the expensive <code>&lt;locale&gt;</code> include.</p>
<pre><code>auto format(const Locale& loc, format_string<T...> fmt, T&&... args);</code></pre>
<pre><code>auto format_to(OutputIt out, const Locale& loc, format_string<T...> fmt, T&&... args);</code></pre>
<pre><code>auto formatted_size(const Locale& loc, format_string<T...> fmt, T&&... args);</code></pre>
<h3 id="legacy-compile-time-format-string-checks-legacy-checks">Legacy Compile-Time Format String Checks {#legacy-checks}</h3>
<p><code>FMT_STRING</code> enables compile-time checks on older compilers. It requires
C++14 or later and is a no-op in C++11.</p>
<p>:: {.doxygendefine}
FMT_STRING
::</p>
<p>To force the use of legacy compile-time checks, define the preprocessor
variable <code>FMT_ENFORCE_COMPILE_STRING</code>. When set, functions accepting
<code>FMT_STRING</code> will fail to compile with regular strings.</p>
<h2 id="range-and-tuple-formatting-ranges-api">Range and Tuple Formatting {#ranges-api}</h2>
<p>The library also supports convenient formatting of ranges and tuples:</p>
<div class="language-text highlight"><pre><span></span><code>#include &lt;fmt/ranges.h&gt;

std::tuple&lt;char, int, float&gt; t{&#39;a&#39;, 1, 2.0f};
// Prints &quot;(&#39;a&#39;, 1, 2.0)&quot;
fmt::print(&quot;{}&quot;, t);
</code></pre></div>
<p>Using <code>fmt::join</code>, you can separate tuple elements with a custom
separator:</p>
<div class="language-text highlight"><pre><span></span><code>#include &lt;fmt/ranges.h&gt;

std::tuple&lt;int, char&gt; t = {1, &#39;a&#39;};
// Prints &quot;1, a&quot;
fmt::print(&quot;{}&quot;, fmt::join(t, &quot;, &quot;));
</code></pre></div>
<pre><code>auto join(Range&& r, string_view sep);</code></pre>
<p><pre><code>embed:rst
Returns a view that formats `range` with elements separated by `sep`.

**Example**::

  std::vector<int> v = {1, 2, 3};
  fmt::print("{}", fmt::join(v, ", "));
  // Output: "1, 2, 3"

``fmt::join`` applies passed format specifiers to the range elements::

  fmt::print("{:02}", fmt::join(v, ", "));
  // Output: "01, 02, 03"
</code></pre> </p>
        <pre><code>auto join(It begin, Sentinel end, string_view sep);</code></pre>
<p>Returns a view that formats the iterator range <code>[begin, end)</code> with elements separated by <code>sep</code>. </p>
        <h2 id="date-and-time-formatting-chrono-api">Date and Time Formatting {#chrono-api}</h2>
<p><code>fmt/chrono.h</code> provides formatters for</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/chrono/duration">std::chrono::duration</a></li>
<li><a href="https://en.cppreference.com/w/cpp/chrono/time_point">std::chrono::time_point</a></li>
<li><a href="https://en.cppreference.com/w/cpp/chrono/c/tm">std::tm</a></li>
</ul>
<p>The format syntax is described in <a href="syntax.html#chrono-format-specifications">Chrono Format Specifications</a>.</p>
<p><strong>Example</strong>:</p>
<div class="language-text highlight"><pre><span></span><code>#include &lt;fmt/chrono.h&gt;

int main() {
  std::time_t t = std::time(nullptr);

  // Prints &quot;The date is 2020-11-07.&quot; (with the current date):
  fmt::print(&quot;The date is {:%Y-%m-%d}.&quot;, fmt::localtime(t));

  using namespace std::literals::chrono_literals;

  // Prints &quot;Default format: 42s 100ms&quot;:
  fmt::print(&quot;Default format: {} {}\n&quot;, 42s, 100ms);

  // Prints &quot;strftime-like format: 03:15:30&quot;:
  fmt::print(&quot;strftime-like format: {:%H:%M:%S}\n&quot;, 3h + 15min + 30s);
}
</code></pre></div>
<pre><code>auto localtime(std::time_t time);</code></pre>
<p>Converts given time since epoch as <code>std::time_t</code> value into calendar time, expressed in local time. Unlike <code>std::localtime</code>, this function is thread-safe on most platforms. </p>
        <pre><code>auto gmtime(std::time_t time);</code></pre>
<p>Converts given time since epoch as <code>std::time_t</code> value into calendar time, expressed in Coordinated Universal Time (UTC). Unlike <code>std::gmtime</code>, this function is thread-safe on most platforms. </p>
        <h2 id="standard-library-types-formatting-std-api">Standard Library Types Formatting {#std-api}</h2>
<p><code>fmt/std.h</code> provides formatters for:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/atomic/atomic"><code>std::atomic</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/atomic/atomic_flag"><code>std::atomic_flag</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/bitset"><code>std::bitset</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/error/error_code"><code>std::error_code</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/filesystem/path"><code>std::filesystem::path</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/variant/monostate"><code>std::monostate</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/source_location"><code>std::source_location</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/thread/id"><code>std::thread::id</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/variant/variant"><code>std::variant</code></a></li>
</ul>
<pre><code>auto ptr(const std::unique_ptr<T, Deleter>& p);</code></pre>
<pre><code>auto ptr(const std::shared_ptr<T>& p);</code></pre>
<h3 id="formatting-variants">Formatting Variants</h3>
<p>A <code>std::variant</code> is only formattable if every variant alternative is
formattable, and requires the <code>__cpp_lib_variant</code> <a href="https://en.cppreference.com/w/cpp/feature_test">library
feature</a>.</p>
<p><strong>Example</strong>:</p>
<div class="language-text highlight"><pre><span></span><code>#include &lt;fmt/std.h&gt;

std::variant&lt;char, float&gt; v0{&#39;x&#39;};
// Prints &quot;variant(&#39;x&#39;)&quot;
fmt::print(&quot;{}&quot;, v0);

std::variant&lt;std::monostate, char&gt; v1;
// Prints &quot;variant(monostate)&quot;
</code></pre></div>
<h2 id="format-string-compilation-compile-api">Format String Compilation {#compile-api}</h2>
<p><code>fmt/compile.h</code> provides format string compilation enabled via the
<code>FMT_COMPILE</code> macro or the <code>_cf</code> user-defined literal. Format strings
marked with <code>FMT_COMPILE</code> or <code>_cf</code> are parsed, checked and converted
into efficient formatting code at compile-time. This supports arguments
of built-in and string types as well as user-defined types with <code>format</code>
functions taking the format context type as a template parameter in
their <code>formatter</code> specializations. For example:</p>
<div class="language-text highlight"><pre><span></span><code>template &lt;&gt; struct fmt::formatter&lt;point&gt; {
  constexpr auto parse(format_parse_context&amp; ctx);

  template &lt;typename FormatContext&gt;
  auto format(const point&amp; p, FormatContext&amp; ctx) const;
};
</code></pre></div>
<p>Format string compilation can generate more binary code compared to the
default API and is only recommended in places where formatting is a
performance bottleneck.</p>
<p>:: {.doxygendefine}
FMT_COMPILE
::</p>
<pre><code>constexpr auto operator""_cf();</code></pre>
<h2 id="terminal-color-and-text-style-color-api">Terminal Color and Text Style {#color-api}</h2>
<p><code>fmt/color.h</code> provides support for terminal color and text style output.</p>
<pre><code>void print(const text_style& ts, format_string<T...> fmt, T&&... args);</code></pre>
<p><pre><code>embed:rst
Formats a string and prints it to stdout using ANSI escape sequences to
specify text formatting.

**Example**::

  fmt::print(fmt::emphasis::bold | fg(fmt::color::red),
             "Elapsed time: {0:.2f} seconds", 1.23);
</code></pre> </p>
        <pre><code>auto fg(detail::color_type foreground);</code></pre>
<p>Creates a text style from the foreground (text) color. </p>
        <p>:: {.doxygenfunction}
bg(detail::color_type)
::</p>
<p>:: {.doxygenfunction}
styled(const T&amp; value, text_style ts)
::</p>
<h2 id="system-apis-os-api">System APIs {#os-api}</h2>
<p>:: {.doxygenclass members=""}
fmt::ostream
::</p>
<p>:: {.doxygenfunction}
fmt::windows_error
::</p>
<h2 id="stdostream-support-ostream-api"><code>std::ostream</code> Support {#ostream-api}</h2>
<p><code>fmt/ostream.h</code> provides <code>std::ostream</code> support including formatting of
user-defined types that have an overloaded insertion operator
(<code>operator&lt;&lt;</code>). In order to make a type formattable via <code>std::ostream</code>
you should provide a <code>formatter</code> specialization inherited from
<code>ostream_formatter</code>:</p>
<div class="language-text highlight"><pre><span></span><code>#include &lt;fmt/ostream.h&gt;

struct date {
  int year, month, day;

  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const date&amp; d) {
    return os &lt;&lt; d.year &lt;&lt; &#39;-&#39; &lt;&lt; d.month &lt;&lt; &#39;-&#39; &lt;&lt; d.day;
  }
};

template &lt;&gt; struct fmt::formatter&lt;date&gt; : ostream_formatter {};

std::string s = fmt::format(&quot;The date is {}&quot;, date{2012, 12, 9});
// s == &quot;The date is 2012-12-9&quot;
</code></pre></div>
<p>:: {.doxygenfunction}
streamed(const T &amp;)
::</p>
<p>:: {.doxygenfunction}
print(std::ostream &amp;os, format_string\&lt;T...&gt; fmt, T&amp;&amp;... args)
::</p>
<h2 id="printf-formatting-printf-api"><code>printf</code> Formatting {#printf-api}</h2>
<p>The header <code>fmt/printf.h</code> provides <code>printf</code>-like formatting
functionality. The following functions use <a href="https://pubs.opengroup.org/onlinepubs/009695399/functions/fprintf.html">printf format string
syntax</a>
with the POSIX extension for positional arguments. Unlike their standard
counterparts, the <code>fmt</code> functions are type-safe and throw an exception
if an argument type doesn\'t match its format specification.</p>
<p>:: {.doxygenfunction}
printf(string_view fmt, const T&amp;... args) -&gt; int
::</p>
<p>:: {.doxygenfunction}
fprintf(std::FILE *f, const S &amp;fmt, const T&amp;... args) -&gt; int
::</p>
<p>:: {.doxygenfunction}
sprintf(const S&amp;, const T&amp;...)
::</p>
<h2 id="wchar_t-support-xchar-api"><code>wchar_t</code> Support {#xchar-api}</h2>
<p>The optional header <code>fmt/xchar.h</code> provides support for <code>wchar_t</code> and
exotic character types.</p>
<p>:: {.doxygenstruct}
fmt::is_char
::</p>
<p>:: {.doxygentypedef}
fmt::wstring_view
::</p>
<p>:: {.doxygentypedef}
fmt::wformat_context
::</p>
<p>:: {.doxygenfunction}
fmt::to_wstring(const T &amp;value)
::</p>
<h2 id="compatibility-with-c20-stdformat">Compatibility with C++20 <code>std::format</code></h2>
<p>{fmt} implements nearly all of the <a href="https://en.cppreference.com/w/cpp/utility/format">C++20 formatting
library</a> with the
following differences:</p>
<ul>
<li>Names are defined in the <code>fmt</code> namespace instead of <code>std</code> to avoid
  collisions with standard library implementations.</li>
<li>Width calculation doesn\'t use grapheme clusterization. The latter has
  been implemented in a separate branch but hasn\'t been integrated yet.</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": ".", "features": ["navigation.tabs", "toc.integrate"], "search": "assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"provider": "mike"}}</script>
    
    
      <script src="assets/javascripts/bundle.081f42fc.min.js"></script>
      
    
  </body>
</html>